
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_paper_demo.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_paper_demo.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_paper_demo.py:


End-to-End Model Analysis
=========================
This tutorial describes how to use each of the major model analyses in Pyapprox
following the exposition in [PYAPPROX2022]_.

First lets load all the necessary modules and set the random seeds for reproducibility.

.. GENERATED FROM PYTHON SOURCE LINES 9-36

.. code-block:: default

    from scipy import stats
    import numpy as np
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    from functools import partial
    import torch
    import time
    from pyapprox.util.configure_plots import mathrm_label, mathrm_labels
    from pyapprox.variables import (
        IndependentMarginalsVariable, print_statistics, AffineTransform)
    from pyapprox.benchmarks import setup_benchmark, list_benchmarks
    from pyapprox.interface.wrappers import (
        ModelEnsemble, TimerModel, WorkTrackingModel,
        evaluate_1darray_function_on_2d_array)
    from pyapprox.surrogates import adaptive_approximate
    from pyapprox.analysis.sensitivity_analysis import (
        run_sensitivity_analysis, plot_sensitivity_indices)
    from pyapprox.bayes.metropolis import (
        loglike_from_negloglike, plot_unnormalized_2d_marginals)
    from pyapprox.bayes.metropolis import MetropolisMCMCVariable
    from pyapprox.expdesign.bayesian_oed import get_bayesian_oed_optimizer
    from pyapprox import multifidelity
    import warnings
    # warnings.filterwarnings("ignore", category=DeprecationWarning)
    np.random.seed(2023)
    torch.manual_seed(2023)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <torch._C.Generator object at 0x16bde39d0>



.. GENERATED FROM PYTHON SOURCE LINES 37-40

The tutorial can save the figures to file if desired. If you do want the plots
set savefig=True
 savefig = True

.. GENERATED FROM PYTHON SOURCE LINES 40-42

.. code-block:: default

    savefig = False








.. GENERATED FROM PYTHON SOURCE LINES 43-44

The following code shows how to create and sample from two independent uniform random variables defined on :math:`[-2, 2]`. We use uniform variables here, but any marginal from the scipy.stats module can be used.

.. GENERATED FROM PYTHON SOURCE LINES 44-50

.. code-block:: default

    nsamples = 30
    univariate_variables = [stats.uniform(-2, 4), stats.uniform(-2, 4)]
    variable = IndependentMarginalsVariable(univariate_variables)
    samples = variable.rvs(nsamples)
    print_statistics(samples)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

               z0         z1    
    count   30.000000  30.000000
    mean    -0.528053   0.197078
    std      0.905072   1.114676
    min     -1.911641  -1.684959
    max      1.722128   1.922229




.. GENERATED FROM PYTHON SOURCE LINES 51-54

PyApprox supports various types of variable transformations. The following code
shows how to use an affinte transformation to map samples from variables
to samples from the variable's canonical form.

.. GENERATED FROM PYTHON SOURCE LINES 54-58

.. code-block:: default

    var_trans = AffineTransform(variable)
    canonical_samples = var_trans.map_to_canonical(samples)
    print_statistics(canonical_samples)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

               z0         z1    
    count   30.000000  30.000000
    mean    -0.264027   0.098539
    std      0.452536   0.557338
    min     -0.955821  -0.842480
    max      0.861064   0.961114




.. GENERATED FROM PYTHON SOURCE LINES 59-65

Pyapprox provides many utilities for interfacing with complex numerical codes.
The following shows how to wrap a model and store the wall time required
to evaluate each sample in a set. First define a function
with a random execution time that takes in one sample at a time, i.e. a
1D array. Then wrap that model so that multiple samples can be evaluated at
once.

.. GENERATED FROM PYTHON SOURCE LINES 65-75

.. code-block:: default

    def fun_pause_1(sample):
        assert sample.ndim == 1
        time.sleep(np.random.uniform(0, .05))
        return np.sum(sample**2)


    def pyapprox_fun_1(samples):
        return evaluate_1darray_function_on_2d_array(fun_pause_1, samples)









.. GENERATED FROM PYTHON SOURCE LINES 76-79

Now wrap the latter function and run it while tracking
their execution times. The last print statement
prints the median execution time of the model.

.. GENERATED FROM PYTHON SOURCE LINES 79-84

.. code-block:: default

    timer_model = TimerModel(pyapprox_fun_1)
    model = WorkTrackingModel(timer_model)
    values = model(samples)
    print(model.work_tracker())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [0.03503788]




.. GENERATED FROM PYTHON SOURCE LINES 85-89

Other wrappers available in PyApprox include those for running multiple models
at once, useful for multi-fidelity methods, wrappers that fix a subset of inputs
to user specified values, wrappers that only return a subset of all
possible model ouputs, and wrappers for evaluating samples in parallel.

.. GENERATED FROM PYTHON SOURCE LINES 91-98

Pyapprox provide numerous benchmarks for verifying, validating and comparing
model analysis algorithms. The following list the names of all benchmarks and
then creates a benchmark that can be used to test the creation of surrogates,
Bayesian inference, and optimal experimental design. This benchmark requires
determining the true coefficients of the Karhunene Loeve expansion (KLE)
used to characterize the uncertain diffusivity field of an advection
diffusion equation. See documentation of the benchmark for more details).

.. GENERATED FROM PYTHON SOURCE LINES 98-105

.. code-block:: default

    print(list_benchmarks())
    noise_stdev = 1 #1e-1
    inv_benchmark = setup_benchmark(
        "advection_diffusion_kle_inversion", kle_nvars=3,
        noise_stdev=noise_stdev, nobs=5, kle_length_scale=0.5)
    print(inv_benchmark.keys())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ['sobol_g', 'ishigami', 'oakley', 'rosenbrock', 'genz', 'cantilever_beam', 'wing_weight', 'piston', 'chemical_reaction', 'random_oscillator', 'coupled_springs', 'hastings_ecology', 'multi_index_advection_diffusion', 'advection_diffusion_kle_inversion', 'polynomial_ensemble', 'tunable_model_ensemble', 'short_column_ensemble', 'parameterized_nonlinear_model']
    dict_keys(['negloglike', 'variable', 'noiseless_obs', 'obs', 'true_sample', 'obs_indices', 'obs_fun', 'KLE', 'mesh'])




.. GENERATED FROM PYTHON SOURCE LINES 106-107

The following plots the modes of the KLE

.. GENERATED FROM PYTHON SOURCE LINES 107-113

.. code-block:: default

    fig, axs = plt.subplots(
        1, inv_benchmark.KLE.nterms, figsize=(8*inv_benchmark.KLE.nterms, 6))
    for ii in range(inv_benchmark.KLE.nterms):
        inv_benchmark.mesh.plot(inv_benchmark.KLE.eig_vecs[:, ii:ii+1], 50,
                                ax=axs[ii])




.. image-sg:: /auto_examples/images/sphx_glr_plot_paper_demo_001.png
   :alt: plot paper demo
   :srcset: /auto_examples/images/sphx_glr_plot_paper_demo_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 114-122

PyApprox provides many popular methods for constructing surrogates
that once constructed can be evaluated in place of a computaionally
expensive simulation model in model analyses. The following code creates
a Gaussian process (GP) surrogate. The function used to construct the surrogate
takes a callback which is evaluated each time the adaptive surrogate is refined.
Here we use to compute the error of the surrogate as it is constructed using
validation data. Uncomment the code to use a polynomial based surrogate instead
of a GP. The user does not have to change any subsequent code

.. GENERATED FROM PYTHON SOURCE LINES 122-144

.. code-block:: default

    validation_samples = inv_benchmark.variable.rvs(100)
    validation_values = inv_benchmark.negloglike(validation_samples)
    nsamples, errors = [], []
    def callback(approx):
        nsamples.append(approx.num_training_samples())
        error = np.linalg.norm(
            approx(validation_samples)-validation_values, axis=0)
        error /= np.linalg.norm(validation_values, axis=0)
        errors.append(error)

    approx_result = adaptive_approximate(
        inv_benchmark.negloglike, inv_benchmark.variable, "gaussian_process",
        {"max_nsamples": 50, "ncandidate_samples": 2e3, "verbose": 0,
         "callback": callback, "kernel_variance": 400})

    # approx_result = adaptive_approximate(
    #     inv_benchmark.negloglike, inv_benchmark.variable, "polynomial_chaos",
    #     {"method": "leja", "options": {
    #         "max_nsamples": 100, "ncandidate_samples": 3e3, "verbose": 0,
    #         "callback": callback}})
    approx = approx_result.approx








.. GENERATED FROM PYTHON SOURCE LINES 145-146

We can plot the errors obtained from the callback with

.. GENERATED FROM PYTHON SOURCE LINES 146-159

.. code-block:: default

    ax = plt.subplots(figsize=(8, 6))[1]
    ax.loglog(nsamples, errors, "o-")
    ax.set_xlabel(mathrm_label("No. Samples"))
    ax.set_ylabel(mathrm_label("Error"))
    ax.set_xticks([10, 25, 50])
    ax.set_yticks([0.3, 0.75, 1.5])
    ax.get_xaxis().set_major_formatter(mpl.ticker.ScalarFormatter())
    ax.minorticks_off()
    ax.get_yaxis().set_major_formatter(mpl.ticker.ScalarFormatter())
    #ax.tick_params(axis='y', which='minor', bottom=False)
    if savefig:
        plt.savefig("gp-error-plot.pdf")




.. image-sg:: /auto_examples/images/sphx_glr_plot_paper_demo_002.png
   :alt: plot paper demo
   :srcset: /auto_examples/images/sphx_glr_plot_paper_demo_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 160-169

Now we will perform a sensitivity analysis. Specifically we compute
variance based sensitivity indices that measure the impact of each KLE mode
on the mismatch between the observed data and the model predictions.
We use the negative log likelihood to characterize this mismatch.
Here we have used the surrogate to speed up the computation of the sensitivity
indices. Uncomment the commented code to use the numerical model. Note
the drastic increase in computational cost. Warning: using the numerical model
will take many minutes. The plots in the figure, generated from
left to right are: main effect, largest Sobol indices and total effect indices.

.. GENERATED FROM PYTHON SOURCE LINES 169-178

.. code-block:: default

    sa_result = run_sensitivity_analysis(
        "surrogate_sobol", approx, inv_benchmark.variable)
    # sa_result = run_sensitivity_analysis(
    #     "sobol", benchmark.negloglike, inv_benchmark.variable)
    axs = plot_sensitivity_indices(
        sa_result)[1]
    if savefig:
        plt.savefig("gp-sa-indices.pdf", bbox_inches="tight")




.. image-sg:: /auto_examples/images/sphx_glr_plot_paper_demo_003.png
   :alt: plot paper demo
   :srcset: /auto_examples/images/sphx_glr_plot_paper_demo_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 179-188

Now we will use the surrogate with Bayesian inference to learn the
coefficients of the KL. Specifically we will draw a set of samples from
the posterior distribution of the KLE given the observed data provided
in the benchmark.

But First we will improve the accuracy of the surrogate
and print out the error which can be compared to the errors previously plotted.
The error of the original surrogate was kept low to demonstrate the ability
to quantify error in the sensitivity indices from using a surrogate.

.. GENERATED FROM PYTHON SOURCE LINES 188-194

.. code-block:: default

    approx.refine(100)
    error = np.linalg.norm(
        approx(validation_samples)-validation_values, axis=0)
    error /= np.linalg.norm(validation_values, axis=0)
    print("Surrogate", error)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Surrogate [0.09102201]




.. GENERATED FROM PYTHON SOURCE LINES 195-203

Now create a MCMCVariable to sample from the posterior. The benchmark
has already formulated the negative log likelihood that is needed. Here
we will use PyApprox's native delayed rejection adaptive metropolis (DRAM)
sampler.

Uncomment the commented code to use the numerical model instead of the surrogate
with the MCMC algorithm. Again note the significant increase in computational
time

.. GENERATED FROM PYTHON SOURCE LINES 203-214

.. code-block:: default

    npost_samples = 200
    loglike = partial(loglike_from_negloglike, approx)
    # loglike = partial(loglike_from_negloglike, inv_benchmark.negloglike)
    mcmc_variable = MetropolisMCMCVariable(
        inv_benchmark.variable, loglike, method_opts={"cov_scaling": 1})
    print(mcmc_variable)
    map_sample = mcmc_variable.maximum_aposteriori_point()
    print("Computed Map Point", map_sample[:, 0])
    post_samples = mcmc_variable.rvs(npost_samples)
    print("Acceptance rate", mcmc_variable._acceptance_rate)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    JointVariable
    Computed Map Point [-0.29435322 -0.50083897  0.33631887]
    Acceptance rate 0.345




.. GENERATED FROM PYTHON SOURCE LINES 215-219

Now plot the posterior samples with the 2D Marginals of the posterior. Note
do not do this with the numerical model as this would take an eternity due
to the cost of evaluating the numerical model, which is much higher relative
to the cost of running the surrogate.

.. GENERATED FROM PYTHON SOURCE LINES 219-228

.. code-block:: default

    plot_unnormalized_2d_marginals(
        mcmc_variable._variable, mcmc_variable._loglike, nsamples_1d=50,
        plot_samples=[
            [post_samples, {"alpha": 0.3, "c": "orange"}],
            [map_sample, {"c": "k", "marker": "X", "s": 100}]],
        unbounded_alpha=0.999)
    if savefig:
        plt.savefig("posterior-samples.pdf", bbox_inches="tight")




.. image-sg:: /auto_examples/images/sphx_glr_plot_paper_demo_004.png
   :alt: plot paper demo
   :srcset: /auto_examples/images/sphx_glr_plot_paper_demo_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 229-235

In the Bayesian inference above we used a fixed number of observations
at randomly chosen spatial locations. However choosing observation locations
is usually a poor idea. Not all observations can reduce the uncertainty
in the parameters equally. Here we use Bayesian optimal experimental design
to choose the 3 best design locations from the previously observed 10 pretending
that we do not know the value of the observations.

.. GENERATED FROM PYTHON SOURCE LINES 235-258

.. code-block:: default

    fig, ax = plt.subplots(1, 1, figsize=(8, 6))
    #plot a single solution to the PDE before overlaying the designs
    inv_benchmark.mesh.plot(
        inv_benchmark.obs_fun._fwd_solver.solve()[:, None], 50, ax=ax)

    ndesign = 3
    design_candidates = inv_benchmark.mesh.mesh_pts[:, inv_benchmark.obs_indices]
    ndesign_candidates = design_candidates.shape[1]
    oed = get_bayesian_oed_optimizer(
        "kl_params", ndesign_candidates, inv_benchmark.obs_fun, noise_stdev,
        inv_benchmark.variable, max_ncollected_obs=ndesign)
    oed_results = []
    for step in range(ndesign):
        results_step = oed.update_design()[1]
        oed_results.append(results_step)
    selected_candidates = design_candidates[:, np.hstack(oed_results)]
    print(selected_candidates)
    ax.plot(design_candidates[0, :], design_candidates[1, :], "rs")
    ax.plot(selected_candidates[0, :], selected_candidates[1, :], "ko")
    if savefig:
        plt.savefig("oed-selected-design.pdf")





.. image-sg:: /auto_examples/images/sphx_glr_plot_paper_demo_005.png
   :alt: plot paper demo
   :srcset: /auto_examples/images/sphx_glr_plot_paper_demo_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Running 1000 outer model evaluations
    Predicted observation bounds 14.015558739913732 1.2516047704780018
    Evaluations took 173.62535405158997
    Running 1000 inner model evaluations
    Evaluations took 164.1499490737915
    Computing utilities in serial took 0.030169010162353516
    Computing utilities in serial took 0.03148293495178223
    Computing utilities in serial took 0.04574394226074219
    [[0.0954915  0.42178277 0.0954915 ]
     [0.05449674 0.85355339 0.05449674]]




.. GENERATED FROM PYTHON SOURCE LINES 259-269

Note that typically optimal
experimental design (OED) would be used before conducting Bayesian inference.
However, because understanding of Bayesian inference is needed to understand
Bayesian OED we reversed the order. OED is much more expensive than a single
Bayesian calibration because it requires solving many calibration problems.
So typically we do not solve the calibration problems in the OED procedure
to the same degree of accuracy as a final calibration. The accuracy of the
calibrations used by OED must only be sufficient to distinguish between designs.
This accuracy is typically much lower than the accuracy required in
estimates of uncertainty in the parameters or predictions needed for decision making tasks such as risk assessment.

.. GENERATED FROM PYTHON SOURCE LINES 271-282

Here we will set up a related benchmark to the one we have been using,
which can be used to demonstrate the forward propagation of uncertainty.
This benchmark uses the steady state solution of the advection diffusion,
obtained with a constant addition of a tracer into the domain at a single
source model as initial condition. A pump at another locations is then activated
to extract the tracer from the domain. The benchmark quantity of interest
measures the change of the tracer concentration in a subomain.
The benchmark provides models of varying cost
and accuracy that use different discretizations of the spatial PDE mesh
and number of time steps which can be used with multi-fideilty methods.
To setup the benchmark use the following

.. GENERATED FROM PYTHON SOURCE LINES 282-289

.. code-block:: default

    fwd_benchmark = setup_benchmark(
        "multi_index_advection_diffusion",
        kle_nvars=inv_benchmark.variable.num_vars(), kle_length_scale=0.5,
        time_scenario=True)
    model = WorkTrackingModel(
        TimerModel(fwd_benchmark.model_ensemble), num_config_vars=1)








.. GENERATED FROM PYTHON SOURCE LINES 290-295

Here we will use Multi-fidelity statistical estimation to compute the
mean value of the QoI to account for the uncertainty in the KLE cofficients.
So first we must compute the covariance between the QoI returned by
each of our models. We use samples from the posterior. But uncommenting
the code below will use samples from the prior.

.. GENERATED FROM PYTHON SOURCE LINES 295-303

.. code-block:: default

    npilot_samples = 20
    generate_samples = inv_benchmark.variable.rvs # for sampling from prior
    # generate_samples = post_samples 
    cov = multifidelity.estimate_model_ensemble_covariance(
        npilot_samples, generate_samples, model,
        fwd_benchmark.model_ensemble.nmodels)[0]
    print(cov)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[0.00246945 0.00194624 0.00208472 0.00164637 0.0024676  0.00194446
      0.0020831  0.00164483]
     [0.00194624 0.00156171 0.00163776 0.00131613 0.001945   0.00156053
      0.00163665 0.0013151 ]
     [0.00208472 0.00163776 0.00179375 0.00141233 0.00208418 0.00163711
      0.00179327 0.00141177]
     [0.00164637 0.00131613 0.00141233 0.00113068 0.00164613 0.00131581
      0.0014121  0.00113038]
     [0.0024676  0.001945   0.00208418 0.00164613 0.00246583 0.00194328
      0.00208263 0.00164464]
     [0.00194446 0.00156053 0.00163711 0.00131581 0.00194328 0.00155941
      0.00163605 0.00131482]
     [0.0020831  0.00163665 0.00179327 0.0014121  0.00208263 0.00163605
      0.00179285 0.00141158]
     [0.00164483 0.0013151  0.00141177 0.00113038 0.00164464 0.00131482
      0.00141158 0.00113013]]




.. GENERATED FROM PYTHON SOURCE LINES 304-309

By using a WorkTrackingModel we can extract the median costs
of evaluatin each model which is needed to predict the
error of the multi-fidelity estimate of the mean which we can
compare to a prediction of the single fidelity estimate that only uses
the highest fidelity model.

.. GENERATED FROM PYTHON SOURCE LINES 309-314

.. code-block:: default

    model_ids = np.asarray([np.arange(fwd_benchmark.model_ensemble.nmodels)])
    model_costs = model.work_tracker(model_ids)
    # make costs in terms of fraction of cost of high-fidelity evaluation
    model_costs /= model_costs[0]








.. GENERATED FROM PYTHON SOURCE LINES 315-317

Now visualize the correlation between the models and their computational
cost relative to the highest-fidelity model cost

.. GENERATED FROM PYTHON SOURCE LINES 317-324

.. code-block:: default

    fig, axs = plt.subplots(1, 2, figsize=(2*8, 6))
    multifidelity.plot_correlation_matrix(
        multifidelity.get_correlation_from_covariance(cov), ax=axs[0])
    multifidelity.plot_model_costs(model_costs, ax=axs[1])
    axs[0].set_title(mathrm_label("Model covariances"))
    axs[1].set_title(mathrm_label("Relative model costs"))




.. image-sg:: /auto_examples/images/sphx_glr_plot_paper_demo_006.png
   :alt: $\mathrm{Model\;covariances}$, $\mathrm{Relative\;model\;costs}$
   :srcset: /auto_examples/images/sphx_glr_plot_paper_demo_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Text(0.5, 1.0, '$\\mathrm{Relative\\;model\\;costs}$')



.. GENERATED FROM PYTHON SOURCE LINES 325-329

Now find the best multi-fidelity estimator among all available option
Note, the exact predicted variance will change from run to run even with the
same seed because the computational time measured will change slightly
for each run

.. GENERATED FROM PYTHON SOURCE LINES 329-337

.. code-block:: default

    best_est, best_model_indices = (
        multifidelity.get_best_models_for_acv_estimator(
            "acvgmfb", cov, model_costs, inv_benchmark.variable, 1e2, max_nmodels=3,
            init_kwargs={"tree_depth": 4}))
    target_cost = 1000
    best_est.allocate_samples(target_cost)
    print("Predicted variance", best_est.optimized_variance)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Predicted variance 5.818767691754899e-07




.. GENERATED FROM PYTHON SOURCE LINES 338-340

Now we can plot the relative performance of the single and multi-fidelity
estimates of the mean before requiring any additional model evaluations

.. GENERATED FROM PYTHON SOURCE LINES 340-362

.. code-block:: default

    hf_cov, hf_cost = cov[:1, :1], model_costs[:1]
    estimators = [
        multifidelity.get_estimator(
            "mc", hf_cov, hf_cost, inv_benchmark.variable),
        best_est]
    target_costs = np.array([1e1, 1e2, 1e3, 1e4], dtype=int)
    optimized_estimators = multifidelity.compare_estimator_variances(
        target_costs, estimators)
    est_labels = mathrm_labels(["MC", "ACV"])
    fig, axs = plt.subplots(1, 2, figsize=(2*8, 6))
    multifidelity.plot_estimator_variances(
        optimized_estimators, est_labels, axs[0],
        ylabel=mathrm_label("Relative Estimator Variance"))
    axs[0].set_xlim(target_costs.min(), target_costs.max())
    nmodels = cov.shape[0]
    model_labels = [
        r"$f_{%d}$" % ii for ii in np.arange(nmodels)[best_model_indices]]
    multifidelity.plot_acv_sample_allocation_comparison(
        optimized_estimators[1], model_labels, axs[1])
    if savefig:
        plt.savefig("acv-variance-reduction.pdf")




.. image-sg:: /auto_examples/images/sphx_glr_plot_paper_demo_007.png
   :alt: plot paper demo
   :srcset: /auto_examples/images/sphx_glr_plot_paper_demo_007.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [9.36376795e+00 9.99359811e+01 9.99658112e+02 9.99907829e+03] 1




.. GENERATED FROM PYTHON SOURCE LINES 363-366

It is clear that the multi-fidelity estimator will be more computationally
efficient for multiple computational budgets (target costs). Once the user
is ready to actually estimate the mean QoI they can use

.. GENERATED FROM PYTHON SOURCE LINES 366-376

.. code-block:: default

    target_cost = 10
    best_est.allocate_samples(target_cost)
    best_model_ensemble = ModelEnsemble(
        [fwd_benchmark.model_ensemble.functions[ii] for ii in best_model_indices])
    samples, values = best_est.generate_data(best_model_ensemble)
    mean = best_est(values)
    print("Mean QoI", mean)

    plt.show()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Mean QoI 0.5062523937469106




.. GENERATED FROM PYTHON SOURCE LINES 377-380

References
^^^^^^^^^^
.. [PYAPPROX2022] `Jakeman J.D., PyApprox: Enabling efficient model analysis. (2022) <https://www.osti.gov/biblio/1879614>`_


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 6 minutes  39.425 seconds)


.. _sphx_glr_download_auto_examples_plot_paper_demo.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_paper_demo.py <plot_paper_demo.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_paper_demo.ipynb <plot_paper_demo.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
