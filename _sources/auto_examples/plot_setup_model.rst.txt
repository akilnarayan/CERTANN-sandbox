
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_setup_model.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_setup_model.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_setup_model.py:


Model Definition
----------------
This tutorial describes how to setup a function with random inputs. 

We start by defining a function of two random variables. We will use the Rosenbrock benchmark. See :func:`pyapprox.benchmarks.benchmarks.setup_rosenbrock_function`

.. GENERATED FROM PYTHON SOURCE LINES 8-17

.. code-block:: default

    import numpy as np
    from scipy import stats
    from pyapprox.variables import IndependentMarginalsVariable


    def fun(samples):
        return np.sum(samples*2, axis=0)[:, None]









.. GENERATED FROM PYTHON SOURCE LINES 18-21

Now lets define the inputs to the function of interest. For independent random variables we use SciPy random variablest to represent each one-dimensional variables. For documentation refer to the `scipy.stats module <https://docs.scipy.org/doc/scipy/reference/stats.html>`_.

We define multivariate random variables by specifying each 1D variable in a list. Here we will setup a 2D variable which is the tensor product of two independent and identically distributed uniform random variables

.. GENERATED FROM PYTHON SOURCE LINES 21-25

.. code-block:: default


    univariate_variables = [stats.uniform(-2, 4), stats.uniform(-2, 4)]
    variable = IndependentMarginalsVariable(univariate_variables)








.. GENERATED FROM PYTHON SOURCE LINES 26-27

To print a summary of the random variable use

.. GENERATED FROM PYTHON SOURCE LINES 27-29

.. code-block:: default

    print(variable)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Independent Marginal Variable
    Number of variables: 2
    Unique variables and global id:
        uniform(loc=[-2],scale=[4]): z0, z1




.. GENERATED FROM PYTHON SOURCE LINES 30-31

We can draw random samples from variable and evaluate the function using

.. GENERATED FROM PYTHON SOURCE LINES 31-35

.. code-block:: default

    nsamples = 1000
    samples = variable.rvs(nsamples)
    values = fun(samples)








.. GENERATED FROM PYTHON SOURCE LINES 36-37

Summary statistics of the samples and values can be printed using

.. GENERATED FROM PYTHON SOURCE LINES 37-40

.. code-block:: default

    from pyapprox.variables import print_statistics
    print_statistics(samples, values)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

               z0         z1         y0    
    count  1000.000000 1000.000000 1000.000000
    mean    -0.038207  -0.041565  -0.159543
    std      1.165293   1.175000   3.340050
    min     -1.992304  -1.996393  -7.725900
    max      1.995606   1.988541   7.762915




.. GENERATED FROM PYTHON SOURCE LINES 41-57

User defined functions
^^^^^^^^^^^^^^^^^^^^^^
PyApprox can be used with pretty much any function provided an appropriate interface is defined. Here will show how to setup a simple function.

PyApprox requires all functions to take 2D np.ndarray with shape (nvars,nsamples) and requires a function to return a 2D np.ndarray with shape (nsampels,nqoi). nqoi==1 for scalar valued functions and nqoi>1 for vectored value functions.

Lets define a function which does not match this criteria and use wrappers provided by PyApprox to convert it to the correct format. Specifically we will define a function that only takes a 1D np.ndarray and returns a scalar. We import these functions from a separate file

.. literalinclude:: ../../../examples/__util.py
  :language: python
  :start-at: def fun_0
  :end-before: def fun_pause_1

.. Note for some reason text like this is needed after the literalinclude
.. Also note that path above is relative to source/auto_examples


.. GENERATED FROM PYTHON SOURCE LINES 57-61

.. code-block:: default


    from __util import pyapprox_fun_0, fun_0
    values = pyapprox_fun_0(samples)








.. GENERATED FROM PYTHON SOURCE LINES 62-63

The function :func:`pyapprox.interface.wrappers.evaluate_1darray_function_on_2d_array` avoids the need to write a for loop but we can do this also and does some checking to make sure values is the correct shape

.. GENERATED FROM PYTHON SOURCE LINES 63-66

.. code-block:: default


    values_loop = np.array([np.atleast_1d(fun_0(s)) for s in samples.T])
    assert np.allclose(values, values_loop)








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.017 seconds)


.. _sphx_glr_download_auto_examples_plot_setup_model.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_setup_model.py <plot_setup_model.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_setup_model.ipynb <plot_setup_model.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
