4c4
< from pyapprox.util.pya_numba import njit
---
> from pyapprox.pya_numba import njit
9,12c9,11
< from pyapprox.util.sys_utilities import trace_error_with_msg
< from pyapprox.util.utilities import get_tensor_product_quadrature_rule
< from pyapprox.variables.risk import conditional_value_at_risk
< from pyapprox.variables.sampling import (
---
> from pyapprox.sys_utilities import trace_error_with_msg
> from pyapprox.risk_measures import conditional_value_at_risk
> from pyapprox.probability_measure_sampling import (
15,16c14,15
< from pyapprox.variables.transforms import (
<     AffineTransform
---
> from pyapprox.variable_transformations import (
>     AffineRandomVariableTransformation
18c17,18
< from pyapprox.surrogates.interp.tensorprod import (
---
> from pyapprox.utilities import (
>     get_tensor_product_quadrature_rule,
21,24c21,22
< from pyapprox.surrogates.polychaos.gpc import (
<     get_univariate_quadrature_rules_from_variable
< )
< from pyapprox.surrogates.interp.barycentric_interpolation import (
---
> from pyapprox import get_univariate_quadrature_rules_from_variable
> from pyapprox.barycentric_interpolation import (
778,780c776,777
< class AbstractBayesianOED(ABC):
<     r"""Base Bayesian OED class"""
< 
---
> class BayesianBatchOED(ABC):
>     @abstractmethod
785,854d781
<         """
<         Constructor.
< 
<         Parameters
<         ----------
<         design_candidates : np.ndarray (nvars, nsamples)
<             The location of all design sample candidates
< 
<         obs_fun : callable
<             Function with the signature
< 
<             `obs_fun(samples) -> np.ndarray(nsamples, nqoi)`
< 
<             That returns noiseless evaluations of the forward model.
< 
<         noise_std : float or np.ndarray (nobs, 1)
<             The standard deviation of the mean zero Gaussian noise added to
<             each observation
< 
<         prior_variable : pya.IndependentMarginalsVariable
<             The prior variable consisting of independent univariate random
<             variables
< 
<         generate_inner_prior_samples : callable
<            Function with the signature
< 
<             `generate_inner_prior_samples(nsamples) -> np.ndarray(
<              nvars, nsamples), np.ndarray(nsamples, 1)`
< 
<             Generate samples and associated weights used to evaluate
<             the evidence computed by the inner loop
<             If None then the function generate_outer_prior_samples is used and
<             weights are assumed to be 1/nsamples. This function is useful if
<             wanting to use multivariate quadrature to evaluate the evidence
< 
<         ninner_loop_samples : integer
<             The number of quadrature samples used for the inner integral that
<             computes the evidence for each realiaztion of the predicted
<             observations
< 
<         nouter_loop_samples : integer
<             The number of Monte Carlo samples used to compute the outer
<             integral over all possible observations
< 
<         quad_method : string
<             The method used to compute the inner loop integral needed to
<             evaluate the evidence for an outer loop sample. Options are
<             ["linear", "quadratic", "gaussian", "monte_carlo"]
<             The first 3 construct tensor product quadrature rules from
<             univariate rules that are respectively piecewise linear,
<             piecewise quadratic or Gauss-quadrature.
< 
<         pre_collected_design_indices : np.ndarray (nobs)
<             The indices into the qoi vector associated with the
<             collected observations
< 
<         econ : boolean
<             Make all inner loop samples the same for all outer loop samples.
<             This reduces number of evaluations of prediction model. Currently
<             this common data is copied and repeated for each outer loop sample
<             so the rest of the code can remain the same. Eventually the data
<             has to be tiled anyway when computing exepcted utility so this is
<             not a big deal.
< 
<         max_eval_concurrency : integer
<             The number of threads used to compute OED design. Warning:
<             this uses multiprocessing.Pool and seems to provide very little
<             benefit and in many cases increases the CPU time.
<         """
< 
965c892
<     def compute_expected_utility(self, collected_design_indices,
---
>     def compute_expected_utility(collected_design_indices,
967c894
<         raise NotImplementedError()
---
>         pass
970,974c897,905
< class BayesianBatchKLOED(AbstractBayesianOED):
<     r"""
<     Compute open-loop OED my maximizing KL divergence between the prior and
<     posterior.
<     """
---
> class BayesianBatchKLOED(BayesianBatchOED):
>     def __init__(self, design_candidates, obs_fun, noise_std,
>                  prior_variable, nouter_loop_samples=1000,
>                  ninner_loop_samples=1000, generate_inner_prior_samples=None,
>                  econ=False, max_eval_concurrency=1):
>         super().__init__(design_candidates, obs_fun, noise_std,
>                          prior_variable, nouter_loop_samples,
>                          ninner_loop_samples, generate_inner_prior_samples,
>                          econ, max_eval_concurrency)
1104c1035
< 
---
>     
1131,1136c1062
< class BayesianBatchDeviationOED(AbstractBayesianOED):
<     r"""
<     Compute open-loop OED by minimizing the deviation on the push forward
<     of the posterior through a QoI model.
<     """
< 
---
> class BayesianBatchDeviationOED(BayesianBatchOED):
1144,1165d1069
<         Constructor.
< 
<         Parameters
<         ----------
<         design_candidates : np.ndarray (nvars, nsamples)
<             The location of all design sample candidates
< 
<         obs_fun : callable
<             Function with the signature
< 
<             `obs_fun(samples) -> np.ndarray(nsamples, nqoi)`
< 
<             That returns noiseless evaluations of the forward model.
< 
<         noise_std : float or np.ndarray (nobs, 1)
<             The standard deviation of the mean zero Gaussian noise added to
<             each observation
< 
<         prior_variable : pya.IndependentMarginalsVariable
<             The prior variable consisting of independent univariate random
<             variables
< 
1167,1234c1071
<             Function with the signature
< 
<             `qoi_fun(samples) -> np.ndarray(nsamples, nqoi)`
< 
<             That returns evaluations of the forward model. Observations are
<             assumed to be :math:`f(z)+\epsilon` where :math:`\epsilon` is
<             additive noise nsamples : np.ndarray (nvars, nsamples)
< 
<         generate_inner_prior_samples : callable
<            Function with the signature
< 
<             `generate_inner_prior_samples(nsamples) -> np.ndarray(
<              nvars, nsamples), np.ndarray(nsamples, 1)`
< 
<             Generate samples and associated weights used to evaluate
<             the evidence computed by the inner loop
<             If None then the function generate_outer_prior_samples is used and
<             weights are assumed to be 1/nsamples. This function is useful if
<             wanting to use multivariate quadrature to evaluate the evidence
< 
<         ninner_loop_samples : integer
<             The number of quadrature samples used for the inner integral that
<             computes the evidence for each realiaztion of the predicted
<             observations
< 
<         nouter_loop_samples : integer
<             The number of Monte Carlo samples used to compute the outer
<             integral over all possible observations
< 
<         quad_method : string
<             The method used to compute the inner loop integral needed to
<             evaluate the evidence for an outer loop sample. Options are
<             ["linear", "quadratic", "gaussian", "monte_carlo"]
<             The first 3 construct tensor product quadrature rules from
<             univariate rules that are respectively piecewise linear,
<             piecewise quadratic or Gauss-quadrature.
< 
<         pre_collected_design_indices : np.ndarray (nobs)
<             The indices into the qoi vector associated with the
<             collected observations
< 
<         econ : boolean
<             Make all inner loop samples the same for all outer loop samples.
<             This reduces number of evaluations of prediction model. Currently
<             this common data is copied and repeated for each outer loop sample
<             so the rest of the code can remain the same. Eventually the data
<             has to be tiled anyway when computing exepcted utility so this is
<             not a big deal.
< 
<          deviation_fun : callable
<              Function with the signature
< 
<             `deviation_fun(inner_loop_pred_qois, weights) ->
<              np.ndarray(nouter_loop_samples, nqois)`
< 
<              where
< 
<              inner_loop_pred_qois : np.ndarray (
<              nouter_loop_samples, ninner_loop_samples, nqois)
<              weights : np.ndarray (nouter_loop_samples, ninner_loop_samples)
< 
<         max_eval_concurrency : integer
<             The number of threads used to compute OED design. Warning:
<             this uses multiprocessing.Pool and seems to provide very little
<             benefit and in many cases increases the CPU time.
< 
<         risk_fun : callable
<             Function with the signature
---
>         Function with the signature
1236c1073
<              `risk_fun(deviations) -> float`
---
>         `qoi_fun(samples) -> np.ndarray(nsamples, nqoi)`
1238c1075,1077
<             where deviations : np.ndarray (nqois, 1)
---
>         That returns evaluations of the forward model. Observations are assumed
>         to be :math:`f(z)+\epsilon` where :math:`\epsilon` is additive noise
>         nsamples : np.ndarray (nvars, nsamples)
1240d1078
< 
1345,1347c1183,1185
< class BayesianSequentialOED(AbstractBayesianOED):
<     r"""
<     Compute sequential optimal experimental designs that collect
---
> class BayesianSequentialOED(BayesianBatchOED):
>     """
>     A class to compute sequential optimal experimental designs that collect
1350d1187
< 
1481,1485d1317
<     r"""
<     Compute closed-loop OED my maximizing KL divergence between the prior and
<     posterior.
<     """
<     
1490,1565d1321
<         r"""
<         Constructor.
< 
<         Parameters
<         ----------
<         design_candidates : np.ndarray (nvars, nsamples)
<             The location of all design sample candidates
< 
<         obs_fun : callable
<             Function with the signature
< 
<             `obs_fun(samples) -> np.ndarray(nsamples, nqoi)`
< 
<             That returns noiseless evaluations of the forward model.
< 
<         noise_std : float or np.ndarray (nobs, 1)
<             The standard deviation of the mean zero Gaussian noise added to
<             each observation
< 
<         prior_variable : pya.IndependentMarginalsVariable
<             The prior variable consisting of independent univariate random
<             variables
< 
<         obs_process : callable
<             The true data generation model with the signature
< 
<             `obs_process(design_indices) -> np.ndarray (1, ndesign_indices)`
< 
<             where design_samples is np.ndarary (nvars, ndesign_indices)
< 
<         generate_inner_prior_samples : callable
<            Function with the signature
< 
<             `generate_inner_prior_samples(nsamples) -> np.ndarray(
<              nvars, nsamples), np.ndarray(nsamples, 1)`
< 
<             Generate samples and associated weights used to evaluate
<             the evidence computed by the inner loop
<             If None then the function generate_outer_prior_samples is used and
<             weights are assumed to be 1/nsamples. This function is useful if
<             wanting to use multivariate quadrature to evaluate the evidence
< 
<         ninner_loop_samples : integer
<             The number of quadrature samples used for the inner integral that
<             computes the evidence for each realiaztion of the predicted
<             observations
< 
<         nouter_loop_samples : integer
<             The number of Monte Carlo samples used to compute the outer
<             integral over all possible observations
< 
<         quad_method : string
<             The method used to compute the inner loop integral needed to
<             evaluate the evidence for an outer loop sample. Options are
<             ["linear", "quadratic", "gaussian", "monte_carlo"]
<             The first 3 construct tensor product quadrature rules from
<             univariate rules that are respectively piecewise linear,
<             piecewise quadratic or Gauss-quadrature.
< 
<         pre_collected_design_indices : np.ndarray (nobs)
<             The indices into the qoi vector associated with the
<             collected observations
< 
<         econ : boolean
<             Make all inner loop samples the same for all outer loop samples.
<             This reduces number of evaluations of prediction model. Currently
<             this common data is copied and repeated for each outer loop sample
<             so the rest of the code can remain the same. Eventually the data
<             has to be tiled anyway when computing exepcted utility so this is
<             not a big deal.
< 
<         max_eval_concurrency : integer
<             The number of threads used to compute OED design. Warning:
<             this uses multiprocessing.Pool and seems to provide very little
<             benefit and in many cases increases the CPU time.   
<         """
1605,1608d1360
<     r"""
<     Compute closed-loop OED by minimizing the deviation on the push forward
<     of the posterior through a QoI model.
<     """
1616,1719d1367
<         r"""
<         Constructor.
< 
<         Parameters
<         ----------
<         design_candidates : np.ndarray (nvars, nsamples)
<             The location of all design sample candidates
< 
<         obs_fun : callable
<             Function with the signature
< 
<             `obs_fun(samples) -> np.ndarray(nsamples, nqoi)`
< 
<             That returns noiseless evaluations of the forward model.
< 
<         noise_std : float or np.ndarray (nobs, 1)
<             The standard deviation of the mean zero Gaussian noise added to
<             each observation
< 
<         prior_variable : pya.IndependentMarginalsVariable
<             The prior variable consisting of independent univariate random
<             variables
< 
<         obs_process : callable
<             The true data generation model with the signature
< 
<             `obs_process(design_indices) -> np.ndarray (1, ndesign_indices)`
< 
<             where design_samples is np.ndarary (nvars, ndesign_indices)
< 
<         qoi_fun : callable
<             Function with the signature
< 
<             `qoi_fun(samples) -> np.ndarray(nsamples, nqoi)`
< 
<             That returns evaluations of the forward model. Observations are
<             assumed to be :math:`f(z)+\epsilon` where :math:`\epsilon` is
<             additive noise nsamples : np.ndarray (nvars, nsamples)
< 
<         generate_inner_prior_samples : callable
<            Function with the signature
< 
<             `generate_inner_prior_samples(nsamples) -> np.ndarray(
<              nvars, nsamples), np.ndarray(nsamples, 1)`
< 
<             Generate samples and associated weights used to evaluate
<             the evidence computed by the inner loop
<             If None then the function generate_outer_prior_samples is used and
<             weights are assumed to be 1/nsamples. This function is useful if
<             wanting to use multivariate quadrature to evaluate the evidence
< 
<         ninner_loop_samples : integer
<             The number of quadrature samples used for the inner integral that
<             computes the evidence for each realiaztion of the predicted
<             observations
< 
<         nouter_loop_samples : integer
<             The number of Monte Carlo samples used to compute the outer
<             integral over all possible observations
< 
<         quad_method : string
<             The method used to compute the inner loop integral needed to
<             evaluate the evidence for an outer loop sample. Options are
<             ["linear", "quadratic", "gaussian", "monte_carlo"]
<             The first 3 construct tensor product quadrature rules from
<             univariate rules that are respectively piecewise linear,
<             piecewise quadratic or Gauss-quadrature.
< 
<         pre_collected_design_indices : np.ndarray (nobs)
<             The indices into the qoi vector associated with the
<             collected observations
< 
<         econ : boolean
<             Make all inner loop samples the same for all outer loop samples.
<             This reduces number of evaluations of prediction model. Currently
<             this common data is copied and repeated for each outer loop sample
<             so the rest of the code can remain the same. Eventually the data
<             has to be tiled anyway when computing exepcted utility so this is
<             not a big deal.
< 
<          deviation_fun : callable
<              Function with the signature
< 
<             `deviation_fun(inner_loop_pred_qois, weights) ->
<              np.ndarray(nouter_loop_samples, nqois)`
< 
<              where
< 
<              inner_loop_pred_qois : np.ndarray (
<              nouter_loop_samples, ninner_loop_samples, nqois)
<              weights : np.ndarray (nouter_loop_samples, ninner_loop_samples)
< 
<         max_eval_concurrency : integer
<             The number of threads used to compute OED design. Warning:
<             this uses multiprocessing.Pool and seems to provide very little
<             benefit and in many cases increases the CPU time.
< 
<         risk_fun : callable
<             Function with the signature
< 
<              `risk_fun(deviations) -> float`
< 
<             where deviations : np.ndarray (nqois, 1)            
<         """
1767c1415
<         var_trans = AffineTransform(prior_variable)
---
>         var_trans = AffineRandomVariableTransformation(prior_variable)
1774c1422
<             transform_samples=var_trans.map_from_canonical)
---
>             transform_samples=var_trans.map_from_canonical_space)
1857c1505
<                       vals)
---
>                       vals[outer_loop_idx, :][:, None])
1930c1578
<     prior_variable : pya.IndependentMarginalsVariable
---
>     prior_variable : pya.IndependentMultivariateRandomVariable
2197,2247d1844
<     r"""
<     Initialize a Bayesian OED optimizer.
< 
<     Parameters
<     ----------
<     short_oed_type : string
<         The type of experimental design strategy
< 
<     design_candidates : np.ndarray (nvars, nsamples)
<         The location of all design sample candidates
< 
<     obs_fun : callable
<         Function with the signature
< 
<         `obs_fun(samples) -> np.ndarray(nsamples, nqoi)`
< 
<         That returns noiseless evaluations of the forward model.
< 
<     noise_std : float or np.ndarray (nobs, 1)
<         The standard deviation of the mean zero Gaussian noise added to each
<         observation
< 
<     ninner_loop_samples : integer
<         The number of quadrature samples used for the inner integral that
<         computes the evidence for each realiaztion of the predicted
<         observations
< 
<     nouter_loop_samples : integer
<         The number of Monte Carlo samples used to compute the outer integral
<         over all possible observations
< 
<     quad_method : string
<         The method used to compute the inner loop integral needed to
<         evaluate the evidence for an outer loop sample. Options are
<         ["linear", "quadratic", "gaussian", "monte_carlo"]
<         The first 3 construct tensor product quadrature rules from univariate
<         rules that are respectively piecewise linear, piecewise quadratic
<         or Gauss-quadrature.
< 
<     pre_collected_design_indices : np.ndarray (nobs)
<         The indices into the qoi vector associated with the
<         collected observations
< 
<     kwargs : kwargs
<         Key word arguments specific to the OED type
< 
<     Returns
<     -------
<     oed : pyapprox.expdesign.AbstractBayesianOED
<         Bayesian OED optimizer object
<     """
