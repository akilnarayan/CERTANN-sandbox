<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyapprox.benchmarks.benchmarks &mdash; PyApprox 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> PyApprox
            <img src="../../../_static/pyapprox-logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Software Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_tutorials/index.html">Theoretical Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Benchmarks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../benchmarks.html">Benchmarks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Reference Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_reference_guide.html">User Reference Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyApprox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>pyapprox.benchmarks.benchmarks</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyapprox.benchmarks.benchmarks</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">OptimizeResult</span>

<span class="kn">from</span> <span class="nn">pyapprox.benchmarks.sensitivity_benchmarks</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_sobol_g_function_statistics</span><span class="p">,</span> <span class="n">get_ishigami_funciton_statistics</span><span class="p">,</span>
    <span class="n">oakley_function</span><span class="p">,</span> <span class="n">oakley_function_statistics</span><span class="p">,</span> <span class="n">sobol_g_function</span><span class="p">,</span>
    <span class="n">ishigami_function</span><span class="p">,</span> <span class="n">ishigami_function_jacobian</span><span class="p">,</span> <span class="n">ishigami_function_hessian</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.benchmarks.surrogate_benchmarks</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">rosenbrock_function</span><span class="p">,</span>
    <span class="n">rosenbrock_function_jacobian</span><span class="p">,</span> <span class="n">rosenbrock_function_hessian_prod</span><span class="p">,</span>
    <span class="n">rosenbrock_function_mean</span><span class="p">,</span> <span class="n">cantilever_beam_constraints_jacobian</span><span class="p">,</span>
    <span class="n">cantilever_beam_constraints</span><span class="p">,</span> <span class="n">cantilever_beam_objective</span><span class="p">,</span>
    <span class="n">cantilever_beam_objective_grad</span><span class="p">,</span> <span class="n">define_beam_random_variables</span><span class="p">,</span>
    <span class="n">define_piston_random_variables</span><span class="p">,</span> <span class="n">piston_function</span><span class="p">,</span>
    <span class="n">define_wing_weight_random_variables</span><span class="p">,</span> <span class="n">wing_weight_function</span><span class="p">,</span>
    <span class="n">wing_weight_gradient</span><span class="p">,</span> <span class="n">define_chemical_reaction_random_variables</span><span class="p">,</span>
    <span class="n">ChemicalReactionModel</span><span class="p">,</span> <span class="n">define_random_oscillator_random_variables</span><span class="p">,</span>
    <span class="n">RandomOscillator</span><span class="p">,</span> <span class="n">piston_function_gradient</span><span class="p">,</span> <span class="n">CoupledSprings</span><span class="p">,</span>
    <span class="n">define_coupled_springs_random_variables</span><span class="p">,</span> <span class="n">HastingsEcology</span><span class="p">,</span>
    <span class="n">define_nondim_hastings_ecology_random_variables</span><span class="p">,</span>
    <span class="n">ParameterizedNonlinearModel</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.benchmarks.genz</span> <span class="kn">import</span> <span class="n">GenzFunction</span>
<span class="kn">from</span> <span class="nn">pyapprox.benchmarks.multifidelity_benchmarks</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PolynomialModelEnsemble</span><span class="p">,</span> <span class="n">TunableModelEnsemble</span><span class="p">,</span> <span class="n">ShortColumnModelEnsemble</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.variables.joint</span> <span class="kn">import</span> <span class="n">IndependentMarginalsVariable</span>
<span class="kn">from</span> <span class="nn">pyapprox.variables.transforms</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ConfigureVariableTransformation</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.interface.wrappers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TimerModel</span><span class="p">,</span> <span class="n">PoolModel</span><span class="p">,</span> <span class="n">WorkTrackingModel</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.benchmarks.pde_benchmarks</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_setup_inverse_advection_diffusion_benchmark</span><span class="p">,</span>
    <span class="n">_setup_multi_index_advection_diffusion_benchmark</span>
<span class="p">)</span>


<div class="viewcode-block" id="Benchmark"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.Benchmark.html#pyapprox.benchmarks.Benchmark">[docs]</a><span class="k">class</span> <span class="nc">Benchmark</span><span class="p">(</span><span class="n">OptimizeResult</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contains functions and results needed to implement known</span>
<span class="sd">    benchmarks.</span>

<span class="sd">    A benchmark can be created with any attribute.</span>
<span class="sd">    Only fun and variable are required. Below are these two required attributes</span>
<span class="sd">    and other optional attributes used in different PyApprox Benchmarks</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        The function being analyzed</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.JointVariable`</span>
<span class="sd">        Class containing information about each of the nvars inputs to fun</span>

<span class="sd">    jac : callable</span>
<span class="sd">        The jacobian of fun. (optional)</span>

<span class="sd">    hess : callable</span>
<span class="sd">        The Hessian of fun. (optional)</span>

<span class="sd">    hessp : callable</span>
<span class="sd">        Function implementing the hessian of fun multiplied by a vector.</span>
<span class="sd">        (optional)</span>

<span class="sd">    mean: np.ndarray (nvars)</span>
<span class="sd">        The mean of the function with respect to the PDF of var</span>

<span class="sd">    variance: np.ndarray (nvars)</span>
<span class="sd">        The variance of the function with respect to the PDF of var</span>

<span class="sd">    main_effects : np.ndarray (nvars)</span>
<span class="sd">        The variance based main effect sensitivity indices</span>

<span class="sd">    total_effects : np.ndarray (nvars)</span>
<span class="sd">        The variance based total effect sensitivity indices</span>

<span class="sd">    sobol_indices : np.ndarray</span>
<span class="sd">        The variance based Sobol sensitivity indices</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Use the `keys()` method to see a list of the available</span>
<span class="sd">    attributes for a specific benchmark</span>
<span class="sd">    &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="setup_sobol_g_function"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_sobol_g_function.html#pyapprox.benchmarks.setup_sobol_g_function">[docs]</a><span class="k">def</span> <span class="nf">setup_sobol_g_function</span><span class="p">(</span><span class="n">nvars</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup the Sobol-G function benchmark</span>

<span class="sd">    .. math:: f(z) = \prod_{i=1}^d\frac{\lvert 4z_i-2\rvert+a_i}{1+a_i}, \quad a_i=\frac{i-2}{2}</span>

<span class="sd">    using</span>

<span class="sd">    &gt;&gt;&gt; from pyapprox.benchmarks.benchmarks import setup_benchmark</span>
<span class="sd">    &gt;&gt;&gt; benchmark=setup_benchmark(&#39;sobol_g&#39;,nvars=2)</span>
<span class="sd">    &gt;&gt;&gt; print(benchmark.keys())</span>
<span class="sd">    dict_keys([&#39;fun&#39;, &#39;mean&#39;, &#39;variance&#39;, &#39;main_effects&#39;, &#39;total_effects&#39;, &#39;variable&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nvars : integer</span>
<span class="sd">        The number of variables of the Sobol-G function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes</span>

<span class="sd">    fun : callable</span>
<span class="sd">        The function being analyzed</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.JointVariable`</span>
<span class="sd">        Class containing information about each of the nvars inputs to fun</span>

<span class="sd">    mean: np.ndarray (nvars)</span>
<span class="sd">        The mean of the function with respect to the PDF of var</span>

<span class="sd">    variance: np.ndarray (nvars)</span>
<span class="sd">        The variance of the function with respect to the PDF of var</span>

<span class="sd">    main_effects : np.ndarray (nvars)</span>
<span class="sd">        The variance based main effect sensitivity indices</span>

<span class="sd">    total_effects : np.ndarray (nvars)</span>
<span class="sd">        The variance based total effect sensitivity indices</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Saltelli1995] `Saltelli, A., &amp; Sobol, I. M. About the use of rank transformation in sensitivity analysis of model output. Reliability Engineering &amp; System Safety, 50(3), 225-239, 1995. &lt;https://doi.org/10.1016/0951-8320(95)00099-2&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">univariate_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="n">nvars</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">IndependentMarginalsVariable</span><span class="p">(</span><span class="n">univariate_variables</span><span class="p">)</span>
    <span class="n">a_param</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nvars</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">mean</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">main_effects</span><span class="p">,</span> <span class="n">total_effects</span> <span class="o">=</span> \
        <span class="n">get_sobol_g_function_statistics</span><span class="p">(</span><span class="n">a_param</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">({</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">sobol_g_function</span><span class="p">,</span> <span class="n">a_param</span><span class="p">),</span>
                      <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean</span><span class="p">,</span> <span class="s1">&#39;variance&#39;</span><span class="p">:</span> <span class="n">variance</span><span class="p">,</span>
                      <span class="s1">&#39;main_effects&#39;</span><span class="p">:</span> <span class="n">main_effects</span><span class="p">,</span>
                      <span class="s1">&#39;total_effects&#39;</span><span class="p">:</span> <span class="n">total_effects</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">})</span></div>


<div class="viewcode-block" id="setup_ishigami_function"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_ishigami_function.html#pyapprox.benchmarks.setup_ishigami_function">[docs]</a><span class="k">def</span> <span class="nf">setup_ishigami_function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup the Ishigami function benchmark</span>

<span class="sd">    .. math:: f(z) = \sin(z_1)+a\sin^2(z_2) + bz_3^4\sin(z_0)</span>

<span class="sd">    using</span>

<span class="sd">    &gt;&gt;&gt; from pyapprox.benchmarks.benchmarks import setup_benchmark</span>
<span class="sd">    &gt;&gt;&gt; benchmark=setup_benchmark(&#39;ishigami&#39;,a=7,b=0.1)</span>
<span class="sd">    &gt;&gt;&gt; print(benchmark.keys())</span>
<span class="sd">    dict_keys([&#39;fun&#39;, &#39;jac&#39;, &#39;hess&#39;, &#39;variable&#39;, &#39;mean&#39;, &#39;variance&#39;, &#39;main_effects&#39;, &#39;total_effects&#39;, &#39;sobol_indices&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : float</span>
<span class="sd">        The hyper-parameter a</span>

<span class="sd">    b : float</span>
<span class="sd">        The hyper-parameter b</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes</span>

<span class="sd">    fun : callable</span>
<span class="sd">        The function being analyzed</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.JointVariable`</span>
<span class="sd">        Class containing information about each of the nvars inputs to fun</span>

<span class="sd">    jac : callable</span>
<span class="sd">        The jacobian of fun. (optional)</span>

<span class="sd">    hess : callable</span>
<span class="sd">        The Hessian of fun. (optional)</span>

<span class="sd">    hessp : callable</span>
<span class="sd">        Function implementing the hessian of fun multiplied by a vector.</span>
<span class="sd">        (optional)</span>

<span class="sd">    mean: np.ndarray (nvars)</span>
<span class="sd">        The mean of the function with respect to the PDF of var</span>

<span class="sd">    variance: np.ndarray (nvars)</span>
<span class="sd">        The variance of the function with respect to the PDF of var</span>

<span class="sd">    main_effects : np.ndarray (nvars)</span>
<span class="sd">        The variance based main effect sensitivity indices</span>

<span class="sd">    total_effects : np.ndarray (nvars)</span>
<span class="sd">        The variance based total effect sensitivity indices</span>

<span class="sd">    sobol_indices : np.ndarray (nsobol_indices)</span>
<span class="sd">        The variance based Sobol sensitivity indices</span>

<span class="sd">    sobol_interaction_indices : np.ndarray(nsobol_indices)</span>
<span class="sd">        The indices of the acitive variable dimensions involved in each</span>
<span class="sd">        sobol index</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Ishigami1990] `T. Ishigami and T. Homma, &quot;An importance quantification technique in uncertainty analysis for computer models,&quot; [1990] Proceedings. First International Symposium on Uncertainty Modeling and Analysis, College Park, MD, USA, 1990, pp. 398-403 &lt;https://doi.org/10.1109/ISUMA.1990.151285&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">univariate_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span><span class="o">*</span><span class="mi">3</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">IndependentMarginalsVariable</span><span class="p">(</span><span class="n">univariate_variables</span><span class="p">)</span>
    <span class="n">mean</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">main_effects</span><span class="p">,</span> <span class="n">total_effects</span><span class="p">,</span> <span class="n">sobol_indices</span><span class="p">,</span> \
        <span class="n">sobol_interaction_indices</span> <span class="o">=</span> <span class="n">get_ishigami_funciton_statistics</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span>
        <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">ishigami_function</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">),</span>
         <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">ishigami_function_jacobian</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">),</span>
         <span class="s1">&#39;hess&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">ishigami_function_hessian</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">),</span>
         <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean</span><span class="p">,</span> <span class="s1">&#39;variance&#39;</span><span class="p">:</span> <span class="n">variance</span><span class="p">,</span>
         <span class="s1">&#39;main_effects&#39;</span><span class="p">:</span> <span class="n">main_effects</span><span class="p">,</span> <span class="s1">&#39;total_effects&#39;</span><span class="p">:</span> <span class="n">total_effects</span><span class="p">,</span>
         <span class="s1">&#39;sobol_indices&#39;</span><span class="p">:</span> <span class="n">sobol_indices</span><span class="p">,</span>
         <span class="s1">&#39;sobol_interaction_indices&#39;</span><span class="p">:</span> <span class="n">sobol_interaction_indices</span><span class="p">})</span></div>


<div class="viewcode-block" id="setup_oakley_function"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_oakley_function.html#pyapprox.benchmarks.setup_oakley_function">[docs]</a><span class="k">def</span> <span class="nf">setup_oakley_function</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup the Oakely function benchmark</span>

<span class="sd">    .. math:: f(z) = a_1^Tz + a_2^T\sin(z) + a_3^T\cos(z) + z^TMz</span>

<span class="sd">    where :math:`z` consists of 15 I.I.D. standard Normal variables and the data :math:`a_1,a_2,a_3` and :math:`~M` are defined in the function :py:func:`~pyapprox.benchmarks.sensitivity_benchmarks.get_oakley_function_data`.</span>

<span class="sd">    &gt;&gt;&gt; from pyapprox.benchmarks.benchmarks import setup_benchmark</span>
<span class="sd">    &gt;&gt;&gt; benchmark=setup_benchmark(&#39;oakley&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(benchmark.keys())</span>
<span class="sd">    dict_keys([&#39;fun&#39;, &#39;variable&#39;, &#39;mean&#39;, &#39;variance&#39;, &#39;main_effects&#39;])</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes</span>

<span class="sd">    fun : callable</span>
<span class="sd">        The function being analyzed</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.JointVariable`</span>
<span class="sd">        Class containing information about each of the nvars inputs to fun</span>

<span class="sd">    mean: np.ndarray (nvars)</span>
<span class="sd">        The mean of the function with respect to the PDF of var</span>

<span class="sd">    variance: np.ndarray (nvars)</span>
<span class="sd">        The variance of the function with respect to the PDF of var</span>

<span class="sd">    main_effects : np.ndarray (nvars)</span>
<span class="sd">        The variance based main effect sensitivity indices</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [OakelyOJRSB2004] `Oakley, J.E. and O&#39;Hagan, A. (2004), Probabilistic sensitivity analysis of complex models: a Bayesian approach. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 66: 751-769. &lt;https://doi.org/10.1111/j.1467-9868.2004.05304.x&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">univariate_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="p">()]</span><span class="o">*</span><span class="mi">15</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">IndependentMarginalsVariable</span><span class="p">(</span><span class="n">univariate_variables</span><span class="p">)</span>
    <span class="n">mean</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">main_effects</span> <span class="o">=</span> <span class="n">oakley_function_statistics</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span>
        <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">oakley_function</span><span class="p">,</span>
         <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean</span><span class="p">,</span> <span class="s1">&#39;variance&#39;</span><span class="p">:</span> <span class="n">variance</span><span class="p">,</span>
         <span class="s1">&#39;main_effects&#39;</span><span class="p">:</span> <span class="n">main_effects</span><span class="p">})</span></div>


<div class="viewcode-block" id="setup_rosenbrock_function"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_rosenbrock_function.html#pyapprox.benchmarks.setup_rosenbrock_function">[docs]</a><span class="k">def</span> <span class="nf">setup_rosenbrock_function</span><span class="p">(</span><span class="n">nvars</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup the Rosenbrock function benchmark</span>

<span class="sd">    .. math:: f(z) = \sum_{i=1}^{d/2}\left[100(z_{2i-1}^{2}-z_{2i})^{2}+(z_{2i-1}-1)^{2}\right]</span>

<span class="sd">    This benchmark can also be used to test Bayesian inference methods.</span>
<span class="sd">    Specifically this benchmarks returns the log likelihood</span>

<span class="sd">    .. math:: l(z) = -f(z)</span>

<span class="sd">    which can be used to compute the posterior distribution</span>

<span class="sd">    .. math:: \pi_{\text{post}}(\rv)=\frac{\pi(\V{y}|\rv)\pi(\rv)}{\int_{\rvdom} \pi(\V{y}|\rv)\pi(\rv)d\rv}</span>

<span class="sd">    where the prior is the tensor product of :math:`d` independent and</span>
<span class="sd">    identically distributed uniform variables on :math:`[-2,2]`, i.e.</span>
<span class="sd">    :math:`\pi(\rv)=\frac{1}{4^d}`, and the likelihood is given by</span>

<span class="sd">    .. math:: \pi(\V{y}|\rv)=\exp\left(l(\rv)\right)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nvars : integer</span>
<span class="sd">        The number of variables of the Rosenbrock function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes documented below</span>

<span class="sd">    fun : callable</span>

<span class="sd">        The rosenbrock function with signature</span>

<span class="sd">        ``fun(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars,nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples,1)</span>

<span class="sd">    jac : callable</span>
<span class="sd">        The jacobian of ``fun`` with signature</span>

<span class="sd">        ``jac(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars,nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nvars,1)</span>

<span class="sd">    hessp : callable</span>
<span class="sd">        Hessian of  ``fun`` times an arbitrary vector p with signature</span>

<span class="sd">        ``hessp(z, p) -&gt;  ndarray shape (nvars,1)``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars,nsamples) and p is an</span>
<span class="sd">        arbitraty vector with shape (nvars,1)</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.IndependentMarginalsVariable`</span>
<span class="sd">        Object containing information of the joint density of the inputs z</span>
<span class="sd">        which is the tensor product of independent and identically distributed</span>
<span class="sd">        uniform variables on :math:`[-2,2]`.</span>

<span class="sd">    mean : float</span>
<span class="sd">        The mean of the rosenbrock function with respect to the pdf of</span>
<span class="sd">        variable.</span>

<span class="sd">    loglike : callable</span>
<span class="sd">        The log likelihood of the Bayesian inference problem for inferring z</span>
<span class="sd">        given the uniform prior specified by variable and the negative</span>
<span class="sd">        log likelihood given by the Rosenbrock function. loglike has the</span>
<span class="sd">        signature</span>

<span class="sd">        ``loglike(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars,nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples,1)</span>

<span class="sd">    loglike_grad : callable</span>
<span class="sd">        The gradient of the ``loglike`` with the signature</span>

<span class="sd">        ``loglike_grad(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars,nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples,1)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [DixonSzego1990] `Dixon, L. C. W.; Mills, D. J. &quot;Effect of Rounding Errors on the Variable Metric Method&quot;. Journal of Optimization Theory and Applications. 80: 175–179. 1994 &lt;https://doi.org/10.1007%2FBF02196600&gt;`_</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pyapprox.benchmarks.benchmarks import setup_benchmark</span>
<span class="sd">    &gt;&gt;&gt; benchmark=setup_benchmark(&#39;rosenbrock&#39;,nvars=2)</span>
<span class="sd">    &gt;&gt;&gt; print(benchmark.keys())</span>
<span class="sd">    dict_keys([&#39;fun&#39;, &#39;jac&#39;, &#39;hessp&#39;, &#39;variable&#39;, &#39;mean&#39;, &#39;loglike&#39;, &#39;loglike_grad&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">univariate_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span><span class="o">*</span><span class="n">nvars</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">IndependentMarginalsVariable</span><span class="p">(</span><span class="n">univariate_variables</span><span class="p">)</span>

    <span class="n">benchmark</span> <span class="o">=</span> <span class="n">Benchmark</span><span class="p">(</span>
        <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">rosenbrock_function</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="n">rosenbrock_function_jacobian</span><span class="p">,</span>
         <span class="s1">&#39;hessp&#39;</span><span class="p">:</span> <span class="n">rosenbrock_function_hessian_prod</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span>
         <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">rosenbrock_function_mean</span><span class="p">(</span><span class="n">nvars</span><span class="p">)})</span>
    <span class="n">benchmark</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;loglike&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">benchmark</span><span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">](</span><span class="n">x</span><span class="p">),</span>
                      <span class="s1">&#39;loglike_grad&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">benchmark</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">](</span><span class="n">x</span><span class="p">)})</span>
    <span class="k">return</span> <span class="n">benchmark</span></div>


<div class="viewcode-block" id="setup_genz_function"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_genz_function.html#pyapprox.benchmarks.setup_genz_function">[docs]</a><span class="k">def</span> <span class="nf">setup_genz_function</span><span class="p">(</span><span class="n">nvars</span><span class="p">,</span> <span class="n">test_name</span><span class="p">,</span> <span class="n">coefficients</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup the Genz Benchmarks.</span>

<span class="sd">    For example, the two-dimensional oscillatory Genz problem can be defined</span>
<span class="sd">    using</span>

<span class="sd">    &gt;&gt;&gt; from pyapprox.benchmarks.benchmarks import setup_benchmark</span>
<span class="sd">    &gt;&gt;&gt; benchmark=setup_benchmark(&#39;genz&#39;,nvars=2,test_name=&#39;oscillatory&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(benchmark.keys())</span>
<span class="sd">    dict_keys([&#39;fun&#39;, &#39;mean&#39;, &#39;variable&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nvars : integer</span>
<span class="sd">        The number of variables of the Genz function</span>

<span class="sd">    test_name : string</span>
<span class="sd">        The test_name of the specific Genz function. See notes</span>
<span class="sd">        for options the string needed is given in brackets</span>
<span class="sd">        e.g. (&#39;oscillatory&#39;)</span>

<span class="sd">    coefficients : tuple (ndarray (nvars), ndarray (nvars))</span>
<span class="sd">        The coefficients :math:`c_i` and :math:`w_i`</span>
<span class="sd">        If None (default) then</span>
<span class="sd">        :math:`c_j = \hat{c}_j\left(\sum_{i=1}^d \hat{c}_i\right)^{-1}` where</span>
<span class="sd">        :math:`\hat{c}_i=(10^{-15\left(\frac{i}{d}\right)^2)})`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes</span>

<span class="sd">    fun : callable</span>
<span class="sd">        The function being analyzed</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.JointVariable`</span>
<span class="sd">        Class containing information about each of the nvars inputs to fun</span>

<span class="sd">    mean: np.ndarray (nvars)</span>
<span class="sd">        The mean of the function with respect to the PDF of var</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Genz1984] `Genz, A. Testing multidimensional integration routines. In Proc. of international conference on Tools, methods and languages for scientific and engineering computation (pp. 81-94), 1984 &lt;https://dl.acm.org/doi/10.5555/2837.2842&gt;`_</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Corner Peak (&#39;corner-peak&#39;)</span>

<span class="sd">    .. math:: f(z)=\left( 1+\sum_{i=1}^d c_iz_i\right)^{-(d+1)}</span>

<span class="sd">    Oscillatory (&#39;oscillatory&#39;)</span>

<span class="sd">    .. math:: f(z) = \cos\left(2\pi w_1 + \sum_{i=1}^d c_iz_i\right)</span>

<span class="sd">    Gaussian Peak (&#39;gaussian-peak&#39;)</span>

<span class="sd">    .. math:: f(z) = \exp\left( -\sum_{i=1}^d c_i^2(z_i-w_i)^2\right)</span>

<span class="sd">    Continuous (&#39;continuous&#39;)</span>

<span class="sd">    .. math:: f(z) = \exp\left( -\sum_{i=1}^d c_i\lvert z_i-w_i\rvert\right)</span>

<span class="sd">    Product Peak (&#39;product-peak&#39;)</span>

<span class="sd">    .. math:: f(z) = \prod_{i=1}^d \left(c_i^{-2}+(z_i-w_i)^2\right)^{-1}</span>

<span class="sd">    Discontinuous (&#39;discontinuous&#39;)</span>

<span class="sd">    .. math:: f(z) = \begin{cases}0 &amp; x_1&gt;u_1 \;\mathrm{or}\; x_2&gt;u_2\\\exp\left(\sum_{i=1}^d c_iz_i\right) &amp; \mathrm{otherwise}\end{cases}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">genz</span> <span class="o">=</span> <span class="n">GenzFunction</span><span class="p">(</span><span class="n">test_name</span><span class="p">,</span> <span class="n">nvars</span><span class="p">)</span>
    <span class="n">univariate_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="n">nvars</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">IndependentMarginalsVariable</span><span class="p">(</span><span class="n">univariate_variables</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coefficients</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">genz</span><span class="o">.</span><span class="n">set_coefficients</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;squared-exponential-decay&#39;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">genz</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">genz</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">coefficients</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">genz</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">genz</span><span class="o">.</span><span class="n">integrate</span><span class="p">(),</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">test_name</span> <span class="o">==</span> <span class="s1">&#39;corner-peak&#39;</span><span class="p">:</span>
        <span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">genz</span><span class="o">.</span><span class="n">variance</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">setup_cantilever_beam_benchmark</span><span class="p">():</span>
    <span class="n">variable</span><span class="p">,</span> <span class="n">design_variable</span> <span class="o">=</span> <span class="n">define_beam_random_variables</span><span class="p">()</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">cantilever_beam_objective</span><span class="p">,</span>
                  <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="n">cantilever_beam_objective_grad</span><span class="p">,</span>
                  <span class="s1">&#39;constraint_fun&#39;</span><span class="p">:</span> <span class="n">cantilever_beam_constraints</span><span class="p">,</span>
                  <span class="s1">&#39;constraint_jac&#39;</span><span class="p">:</span> <span class="n">cantilever_beam_constraints_jacobian</span><span class="p">,</span>
                  <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span>
                  <span class="s1">&#39;design_variable&#39;</span><span class="p">:</span> <span class="n">design_variable</span><span class="p">,</span>
                  <span class="s1">&#39;design_var_indices&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])}</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>


<div class="viewcode-block" id="setup_piston_benchmark"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_piston_benchmark.html#pyapprox.benchmarks.setup_piston_benchmark">[docs]</a><span class="k">def</span> <span class="nf">setup_piston_benchmark</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes documented below</span>

<span class="sd">    fun : callable</span>

<span class="sd">        The piston model with signature</span>

<span class="sd">        ``fun(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars,nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples,1)</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.IndependentMarginalsVariable`</span>
<span class="sd">        Object containing information of the joint density of the inputs z</span>
<span class="sd">        which is the tensor product of independent and identically distributed</span>
<span class="sd">        uniform variables`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Moon2010] `Design and Analysis of Computer Experiments for Screening Input Variables (Doctoral dissertation, Ohio State University) &lt;http://rave.ohiolink.edu/etdc/view?acc_num=osu1275422248&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">define_piston_random_variables</span><span class="p">()</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">piston_function</span><span class="p">,</span>
                  <span class="s2">&quot;jac&quot;</span><span class="p">:</span> <span class="n">piston_function_gradient</span><span class="p">,</span>
                  <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span></div>


<div class="viewcode-block" id="setup_wing_weight_benchmark"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_wing_weight_benchmark.html#pyapprox.benchmarks.setup_wing_weight_benchmark">[docs]</a><span class="k">def</span> <span class="nf">setup_wing_weight_benchmark</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup the wing weight model benchmark.</span>

<span class="sd">    The model is given by</span>


<span class="sd">    .. math::</span>

<span class="sd">       f(x) = 0.036\; S_w^{0.758}W_{fw}^{0.0035}\left(\frac{A}{\cos^2(\Lambda)}\right)^{0.6}q^{0.006}\lambda^{0.04}\left(\frac{100t_c}{\cos(\Lambda)}\right)^{-0.3}(N_zW_{dg})^{0.49}+S_wW_p,</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes documented below</span>

<span class="sd">    fun : callable</span>

<span class="sd">        The wing weight model with signature</span>

<span class="sd">        ``fun(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars,nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples,1)</span>

<span class="sd">    jac : callable</span>
<span class="sd">        The jacobian of ``fun`` with signature</span>

<span class="sd">        ``jac(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars,nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nvars,1)</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.IndependentMarginalsVariable`</span>
<span class="sd">        Object containing information of the joint density of the inputs z</span>
<span class="sd">        which is the tensor product of independent and identically distributed</span>
<span class="sd">        uniform variables`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Moon2012] `Moon, H., Dean, A. M., &amp; Santner, T. J. (2012). Two-stage sensitivity-based group screening in computer experiments. Technometrics, 54(4), 376-387. &lt;https://doi.org/10.1080/00401706.2012.725994&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">define_wing_weight_random_variables</span><span class="p">()</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">wing_weight_function</span><span class="p">,</span>
                  <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span>
                  <span class="s1">&#39;jac&#39;</span><span class="p">:</span>  <span class="n">wing_weight_gradient</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">setup_chemical_reaction_benchmark</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup the chemical reaction model benchmark</span>

<span class="sd">    Model of species absorbing onto a surface out of gas phase</span>
<span class="sd">    u = y[0] = monomer species</span>
<span class="sd">    v = y[1] = dimer species</span>
<span class="sd">    w = y[2] = inert species</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes documented below</span>

<span class="sd">    fun : callable</span>

<span class="sd">        The piston model with signature</span>

<span class="sd">        ``fun(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars,nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples,1)</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.IndependentMarginalsVariable`</span>
<span class="sd">        Object containing information of the joint density of the inputs z</span>
<span class="sd">        which is the tensor product of independent and identically distributed</span>
<span class="sd">        uniform variables`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Vigil et al., Phys. Rev. E., 1996; Makeev et al., J. Chem. Phys., 2002</span>
<span class="sd">    Bert Debuschere used this example 2014 talk</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">define_chemical_reaction_random_variables</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ChemicalReactionModel</span><span class="p">()</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span>
                  <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">setup_random_oscillator_benchmark</span><span class="p">():</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">define_random_oscillator_random_variables</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">RandomOscillator</span><span class="p">()</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span>
                  <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">setup_coupled_springs_benchmark</span><span class="p">():</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">define_coupled_springs_random_variables</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">CoupledSprings</span><span class="p">()</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span>
                  <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">setup_hastings_ecology_benchmark</span><span class="p">(</span><span class="n">qoi_functional</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">define_nondim_hastings_ecology_random_variables</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">HastingsEcology</span><span class="p">(</span><span class="n">qoi_functional</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span>
                  <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>


<div class="viewcode-block" id="setup_polynomial_ensemble"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_polynomial_ensemble.html#pyapprox.benchmarks.setup_polynomial_ensemble">[docs]</a><span class="k">def</span> <span class="nf">setup_polynomial_ensemble</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an ensemble of 5 univariate models of the form</span>

<span class="sd">    .. math:: f_\alpha(\rv)=\rv^{5-\alpha}, \quad \alpha=0,\ldots,4</span>

<span class="sd">    where :math:`z\sim\mathcal{U}[0, 1]`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes</span>

<span class="sd">    fun : callable</span>
<span class="sd">        The function being analyzed</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.JointVariable`</span>
<span class="sd">        Class containing information about each of the nvars inputs to fun</span>

<span class="sd">    means : np.ndarray (nmodels)</span>
<span class="sd">        The mean of each model fidelity</span>

<span class="sd">    model_covariance : np.ndarray (nmodels)</span>
<span class="sd">        The covariance between the outputs of each model fidelity</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [GGEJJCP2020] `A generalized approximate control variate framework for multifidelity uncertainty quantification,  Journal of Computational Physics,  408:109257, 2020. &lt;https://doi.org/10.1016/j.jcp.2020.109257&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">PolynomialModelEnsemble</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span>
        <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="s2">&quot;means&quot;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">get_means</span><span class="p">(),</span>
         <span class="s2">&quot;model_covariance&quot;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">get_covariance_matrix</span><span class="p">()})</span></div>


<span class="k">def</span> <span class="nf">setup_tunable_model_ensemble</span><span class="p">(</span><span class="n">theta1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">TunableModelEnsemble</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">shifts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span>
        <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="s2">&quot;means&quot;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">get_means</span><span class="p">(),</span>
         <span class="s2">&quot;model_covariance&quot;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">get_covariance_matrix</span><span class="p">()})</span>


<span class="k">def</span> <span class="nf">setup_short_column_ensemble</span><span class="p">():</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ShortColumnModelEnsemble</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span>
        <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="s2">&quot;means&quot;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">get_means</span><span class="p">(),</span>
         <span class="s2">&quot;model_covariance&quot;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">get_covariance_matrix</span><span class="p">()})</span>


<span class="k">def</span> <span class="nf">setup_parameterized_nonlinear_model</span><span class="p">():</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ParameterizedNonlinearModel</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">marginals</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="o">-</span><span class="n">lb</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">ranges</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">IndependentMarginalsVariable</span><span class="p">(</span><span class="n">marginals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span>
        <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">})</span>


<div class="viewcode-block" id="setup_multi_index_advection_diffusion_benchmark"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_multi_index_advection_diffusion_benchmark.html#pyapprox.benchmarks.setup_multi_index_advection_diffusion_benchmark">[docs]</a><span class="k">def</span> <span class="nf">setup_multi_index_advection_diffusion_benchmark</span><span class="p">(</span>
        <span class="n">kle_nvars</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">kle_length_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">kle_stdev</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">max_eval_concurrency</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_scenario</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">functional</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">config_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This benchmark is used to test methods for forward propagation of </span>
<span class="sd">    uncertainty. The forward simulation model is the transient </span>
<span class="sd">    advection-diffusion model</span>

<span class="sd">    .. math::</span>

<span class="sd">       \frac{\partial u}{\partial t}(x,t,\rv) &amp;= \nabla\cdot\left[k(x,\rv) \nabla u(x,t,\rv)\right] -\nabla u(x,t,\rv)+g(x,t) &amp;(x,t,\rv)\in D\times [0,1]\times\rvdom\\</span>
<span class="sd">       \mathcal{B}(x,t,\rv)&amp;=0  &amp;(x,t,\rv)\in \partial D\times[0,1]\times\rvdom\\</span>
<span class="sd">       u(x,t,\rv)&amp;=u_0(x,\rv) &amp; (x,t,\rv)\in D\times\{t=0\}\times\rvdom</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>

<span class="sd">        g(x,t)=\frac{100}{2\pi 0.1^2}\exp\left(-\frac{\lvert x-[0.25,0.75]^\top\rvert^2}{2\cdot 0.1^2}\right)-\frac{s_\mathrm{sink}}{2\pi h_\mathrm{sink}^2}\exp\left(-\frac{\lvert x-x_\mathrm{sink}\rvert^2}{2h_\mathrm{sink}^2}\right)</span>

<span class="sd">    and :math:`B(x,t,z)` is set to enforce Dirichlet boundary conditions, i.e.</span>

<span class="sd">    .. math:: u(x) = 0 \quad\mathrm{on} \quad\partial D</span>


<span class="sd">    As with the :py:func:`pyapprox.benchmarks.setup_advection_diffusion_kle_inversion_benchmark`</span>
<span class="sd">    we parameterize the uncertain diffusivity with a Karhunen Loeve Expansion (KLE)</span>

<span class="sd">    .. math:: k(x, \rv)=\exp\left(\sum_{d=1}^D \sqrt{\lambda_d}\psi_d(x)\rv_d\right).</span>

<span class="sd">    If no initial condition is provided by the user then the governing equations in :py:func:`pyapprox.benchmarks.setup_advection_diffusion_kle_inversion_benchmark` is used to create an initial condition, where the forcing is set to be the first term of :math:`g` here. I.e. the steady state solution before the second term of :math:`g` is used to remove the concentration :math:`u` from the domain.</span>

<span class="sd">    The quantity of interest :math:`f(z)` is the integral of the final solution in the subdomain :math:`S=[0.75, 1]\times[0, 0.25]`, i.e.</span>

<span class="sd">    .. math:: f(z)=\int_S u(x,T,z) dx</span>

<span class="sd">    This model can be evaluated using different numerical discreizations that control the two spatial mesh resolutions and the timestep. The model is evaluated by specifying the random variables and the three numerical (configuration) variables.</span>

<span class="sd">    If not time_scenario is provided. The QoI from the steady state solution is returned.</span>

<span class="sd">    This benchmark can be modified by</span>
<span class="sd">    changing the default keyword arguments if necessary but is not recommended.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nvars : integer</span>
<span class="sd">        The number of variables of the KLE</span>

<span class="sd">    kle_length_scale : float</span>
<span class="sd">        The correlation length :math:`L_c` of the covariance kernel</span>

<span class="sd">    kle_sigma : float</span>
<span class="sd">        The standard deviation of the KLE kernel</span>

<span class="sd">    max_eval_concurrency : integer</span>
<span class="sd">        The maximum number of simulations that can be run in parallel. Should be         no more than the maximum number of cores on the computer being used</span>

<span class="sd">    time_scenario : dict</span>
<span class="sd">        Options defining the transient simulation. If None a steady state problem will be solved</span>
<span class="sd">        If True the default time scenario will be used which corresponds to specifying the dictionary</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           time_scenario = {</span>
<span class="sd">               &quot;final_time&quot;: 0.2,</span>
<span class="sd">               &quot;butcher_tableau&quot;: &quot;im_crank2&quot;,</span>
<span class="sd">               &quot;deltat&quot;: 0.1,  # default will be overwritten</span>
<span class="sd">               &quot;init_sol_fun&quot;: None,</span>
<span class="sd">               &quot;sink&quot;: [50, 0.1, [0.75, 0.75]]</span>
<span class="sd">               }</span>

<span class="sd">        Respectively, the entries of sink are :math:`s_\mathrm{sink}, h_\mathrm{sink}, x_\mathrm{sink}`</span>
<span class="sd">        init_sol is a callable function with signature ``init_sol_fun(x) -&gt; np.ndarray (nx, 1)``</span>
<span class="sd">        where ``x`` is np.ndarray (nphys_vars, nx) are physical coordinates in the mesh. ``butcher_tableau`` specifies the time-stepping scheme which can be either</span>
<span class="sd">        ``im_beuler1`` or ``im_crank2``. ``final_time`` specifies :math:`T`.</span>

<span class="sd">    functional : callable</span>
<span class="sd">        Function used to compute the Quantities of interest with signature</span>

<span class="sd">        ``functional(sol, z) -&gt; float``</span>

<span class="sd">        Here ``sol: torch.tensor (ndof)`` is the solution at the mesh points</span>
<span class="sd">        and ``z -&gt; np.ndarray(nkle_vars, 1)`` is the value of the KLE</span>
<span class="sd">        coefficients that produced ``sol``. If None the subdomain intergral</span>
<span class="sd">        of sol at the final time will be used as defined above.</span>

<span class="sd">    config_values : list (np.ndarray)</span>
<span class="sd">        List with three entries (two if time_scenario=None) The first two are</span>
<span class="sd">        the values of the degrees that can be used to construct the</span>
<span class="sd">        collocation mesh in each physical direction. The third is an array of</span>
<span class="sd">        the timestep sizes that can be used to integrate the PDE in time.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes documented below</span>

<span class="sd">    fun : callable</span>

<span class="sd">        The quantity of interest :math:`f(w)` with signature</span>

<span class="sd">        ``fun(w) -&gt; np.ndarray``</span>

<span class="sd">        where ``w`` is a 2D np.ndarray with shape (nvars+3,nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples,1). The first ``nvars``</span>
<span class="sd">        rows of ``w`` are realizations of the random variables. The last 3 rows</span>
<span class="sd">        are configuration variables specifying the numerical discretization of</span>
<span class="sd">        the PDE model. See config_values documentation above. This is useful</span>
<span class="sd">        for testing multi-index multi-fidelity methods.</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.joint.IndependentMarginalsVariable`</span>
<span class="sd">        Object containing information of the joint density of the inputs z</span>
<span class="sd">        which is the tensor product of independent and identically distributed</span>
<span class="sd">        Gaussian variables :math:`\mathcal{N}(0,1)`.</span>

<span class="sd">    get_num_degrees_of_freedom : callable</span>
<span class="sd">        Function that returns the number of mesh points multiplied by the</span>
<span class="sd">        number of timesteps, with signature</span>

<span class="sd">        ``get_num_degrees_of_freedom(v) -&gt; int``</span>

<span class="sd">        where ``v-&gt;np.ndarray(3)`` are the thre configuration values</span>
<span class="sd">        specifiying the numerical discretization</span>

<span class="sd">    config_var_trans : :py:class:`~pyapprox.variables.transforms.ConfigureVariableTransformation`</span>
<span class="sd">        A transform that maps the configuration values to and from a canonical space.</span>

<span class="sd">    model_ensemble : :py:class:`~pyapprox.interface.wrappers.ModelEnsemble`</span>
<span class="sd">       Function return the quantities of interest with the signature</span>
<span class="sd">    </span>
<span class="sd">       ``fun(w) -&gt; np.ndarray``</span>

<span class="sd">        where ``w`` is a 2D np.ndarray with shape (nvars+1, nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples, 1). The first ``nvars``</span>
<span class="sd">        rows of ``w`` are realizations of the random variables. The last row</span>
<span class="sd">        is a model ID specifying a different numerical discretization. This is useful for testing</span>
<span class="sd">        multi-fidelity approximate control variate Monte Carlo estimators.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pyapprox_dev.benchmarks.benchmarks import setup_benchmark</span>
<span class="sd">    &gt;&gt;&gt; benchmark = setup_benchmark(&#39;multi_index_advection_diffusion&#39;, nvars=2)</span>
<span class="sd">    &gt;&gt;&gt; print(benchmark.keys())</span>
<span class="sd">    dict_keys([&#39;fun&#39;, &#39;variable&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_model</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">config_var_trans</span><span class="p">,</span> <span class="n">model_ensemble</span> <span class="o">=</span> <span class="p">(</span>
         <span class="n">_setup_multi_index_advection_diffusion_benchmark</span><span class="p">(</span>
            <span class="n">kle_length_scale</span><span class="p">,</span> <span class="n">kle_stdev</span><span class="p">,</span> <span class="n">kle_nvars</span><span class="p">,</span> <span class="n">time_scenario</span><span class="o">=</span><span class="n">time_scenario</span><span class="p">,</span>
            <span class="n">functional</span><span class="o">=</span><span class="n">functional</span><span class="p">,</span> <span class="n">config_values</span><span class="o">=</span><span class="n">config_values</span><span class="p">))</span>
    <span class="n">timer_model</span> <span class="o">=</span> <span class="n">TimerModel</span><span class="p">(</span><span class="n">base_model</span><span class="p">,</span> <span class="n">base_model</span><span class="p">)</span>
    <span class="n">pool_model</span> <span class="o">=</span> <span class="n">PoolModel</span><span class="p">(</span>
        <span class="n">timer_model</span><span class="p">,</span> <span class="n">max_eval_concurrency</span><span class="p">,</span> <span class="n">base_model</span><span class="o">=</span><span class="n">base_model</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">WorkTrackingModel</span><span class="p">(</span><span class="n">pool_model</span><span class="p">,</span> <span class="n">base_model</span><span class="p">,</span>
                              <span class="n">base_model</span><span class="o">.</span><span class="n">_nconfig_vars</span><span class="p">)</span>
    <span class="n">model0</span> <span class="o">=</span> <span class="n">base_model</span><span class="o">.</span><span class="n">_model_ensemble</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span>
        <span class="s2">&quot;get_num_degrees_of_freedom&quot;</span><span class="p">:</span> <span class="n">model0</span><span class="o">.</span><span class="n">get_num_degrees_of_freedom_cost</span><span class="p">,</span>
        <span class="s2">&quot;config_var_trans&quot;</span><span class="p">:</span> <span class="n">config_var_trans</span><span class="p">,</span>
        <span class="s1">&#39;model_ensemble&#39;</span><span class="p">:</span> <span class="n">model_ensemble</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span></div>


<div class="viewcode-block" id="setup_advection_diffusion_kle_inversion_benchmark"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_advection_diffusion_kle_inversion_benchmark.html#pyapprox.benchmarks.setup_advection_diffusion_kle_inversion_benchmark">[docs]</a><span class="k">def</span> <span class="nf">setup_advection_diffusion_kle_inversion_benchmark</span><span class="p">(</span>
        <span class="n">source_loc</span><span class="o">=</span><span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">],</span> <span class="n">source_amp</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">source_width</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">kle_length_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">kle_stdev</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kle_nvars</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">true_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orders</span><span class="o">=</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="n">noise_stdev</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">nobs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_eval_concurrency</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">obs_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A benchmark for testing maximum likelihood estimation and Bayesian inference algorithms that involves</span>
<span class="sd">    learning the uncertain parameters :math:`\rv` from synthteically generated observational data using</span>
<span class="sd">    the model</span>

<span class="sd">    .. math::</span>

<span class="sd">        \nabla u(x,t,\rv)-\nabla\cdot\left[k(x,\rv) \nabla u(x,t,\rv)\right] &amp;=g(x,t) \qquad (x,t,\rv)\in D\times [0,1]\times\rvdom\\</span>
<span class="sd">       \mathcal{B}(x,t,\rv)&amp;=0 \qquad\qquad (x,t,\rv)\in \partial D\times[0,1]\times\rvdom\\</span>
<span class="sd">       u(x,t,\rv)&amp;=u_0(x,\rv) \qquad (x,t,\rv)\in D\times\{t=0\}\times\rvdom</span>

<span class="sd">    Following [MNRJCP2006]_, [LMSISC2014]_ we set</span>

<span class="sd">    .. math:: g(x,t)=\frac{s_\mathrm{src}}{2\pi h_\mathrm{src}^2}\exp\left(-\frac{\lvert x-x_\mathrm{src}\rvert^2}{2h_\mathrm{src}^2}\right)</span>

<span class="sd">    the initial condition as :math:`u(x,z)=0`, :math:`B(x,t,z)` to be zero Dirichlet boundary conditions, i.e.</span>

<span class="sd">    .. math:: u(x) = 0 \quad\mathrm{on} \quad\partial D</span>

<span class="sd">    and we model the diffusivity as a Karhunen Loeve Expansion (KLE)</span>

<span class="sd">    .. math:: k(x, \rv)=\exp\left(\sum_{d=1}^D \sqrt{\lambda_d}\psi_d(x)\rv_d\right).</span>

<span class="sd">    The observations are noisy  observations :math:`u(x_l)`</span>
<span class="sd">    at :math:`L` locations :math:`\{x_l\}_{l=1}^L` with additive independent Gaussian noise</span>
<span class="sd">    with mean zero and variance :math:`\sigma^2`.</span>
<span class="sd">    These observations can be used to define the posterior distribution</span>

<span class="sd">    .. math::  \pi_{\text{post}}(\rv)=\frac{\pi(\V{y}|\rv)\pi(\rv)}{\int_{\rvdom} \pi(\V{y}|\rv)\pi(\rv)d\rv}</span>

<span class="sd">    where the prior is the tensor product of independent and identically</span>
<span class="sd">    distributed Gaussian with zero mean and unit variance</span>
<span class="sd">    In this scenario the likelihood is given by</span>

<span class="sd">    .. math:: \pi(\V{y}|\rv)=\frac{1}{(2\pi)^{d/2}\sigma}\exp\left(-\frac{1}{2}\frac{(y-f(\rv))^T(y-f(\rv))}{\sigma^2}\right)</span>

<span class="sd">    which can be used for Bayesian inference and maximum likelihood estimation of the parameters</span>
<span class="sd">    :math:`\rv`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_loc : np.ndarray (2)</span>
<span class="sd">        The center of the source</span>

<span class="sd">    source_amp : float</span>
<span class="sd">        The source strength :math:`s`</span>

<span class="sd">    source_width : float</span>
<span class="sd">        The source width :math:`h`</span>

<span class="sd">    kle_length_scale : float</span>
<span class="sd">        The length scale of the KLE</span>

<span class="sd">    kle_stdev : float</span>
<span class="sd">        The standard deviation of the KLE covariance kernel</span>

<span class="sd">    kle_nvars : integer</span>
<span class="sd">        The number of KLE modes</span>

<span class="sd">    true_sample : np.ndarray (2)</span>
<span class="sd">        The true location of the source used to generate the observations</span>
<span class="sd">        used in the likelihood function</span>

<span class="sd">    orders : np.ndarray (2)</span>
<span class="sd">        The degrees of the collocation polynomials in each mesh dimension</span>

<span class="sd">    nobs : integer</span>
<span class="sd">         The number of observations :math:`L`</span>

<span class="sd">    obs_indices : np.ndarray (nobs)</span>
<span class="sd">         The indices of the collocation mesh at which observations are</span>
<span class="sd">         collected. If not specified the indices will be chosen randomly</span>
<span class="sd">         ensuring that no indices associated with boundary segments are</span>
<span class="sd">         selected.</span>

<span class="sd">    noise_stdev : float</span>
<span class="sd">        The standard deviation :math:`\sigma` of the observational noise</span>

<span class="sd">    max_eval_concurrency : integer</span>
<span class="sd">        The maximum number of simulations that can be run in parallel. Should</span>
<span class="sd">        be no more than the maximum number of cores on the computer being used</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes documented below</span>

<span class="sd">    negloglike : callable</span>

<span class="sd">        The negative log likelihood :math:`\exp(\pi(\V{y}|\rv))` with signature</span>

<span class="sd">        ``negloglike(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars, nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples, 1).</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.joint.IndependentMarginalsVariable`</span>
<span class="sd">        Object containing information of the joint density of the inputs z</span>
<span class="sd">        which is the tensor product of independent and identically distributed</span>
<span class="sd">        uniform variables on :math:`[0,1]`.</span>

<span class="sd">    noiseless_obs : np.ndarray (nobs)</span>
<span class="sd">        The solution :math:`u(x_l)` at the :math:`L` locations</span>
<span class="sd">        :math:`\{x_l\}_{l=1}^L` determined by ``obs_indices``</span>

<span class="sd">    obs : np.ndarray (nobs)</span>
<span class="sd">        The noisy observations :math:`u(x_l)+\epsilon_l`</span>

<span class="sd">    true_sample : np.ndarray (nkle_vars)</span>
<span class="sd">        The KLE coefficients used to generate the noisy observations</span>

<span class="sd">    obs_indices : np.ndarray (nobs)</span>
<span class="sd">         The indices of the collocation mesh at which observations are</span>
<span class="sd">         collected. If not specified the indices will be chosen randomly</span>
<span class="sd">         ensuring that no indices associated with boundary segments are</span>
<span class="sd">         selected.</span>

<span class="sd">    obs_fun : callable</span>

<span class="sd">        The function used to generate the noisless observations with signature</span>

<span class="sd">        ``obs_fun(z) -&gt; np.ndarray``</span>

<span class="sd">        where ``z`` is a 2D np.ndarray with shape (nvars, nsamples) and the</span>
<span class="sd">        output is a 2D np.ndarray with shape (nsamples, nobs).</span>

<span class="sd">    KLE : :py:class:`~pyapprox.pde.karhunen_loeve_expansion.MeshKLE`</span>
<span class="sd">        KLE object containing the attributes needed to evaluate the KLE</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pyapprox_dev.benchmarks.benchmarks import setup_benchmark</span>
<span class="sd">    &gt;&gt;&gt; benchmark = setup_benchmark(&#39;advection_diffusion_kle_inversion&#39;, nvars=2)</span>
<span class="sd">    &gt;&gt;&gt; print(benchmark.keys())</span>
<span class="sd">    dict_keys([&#39;fun&#39;, &#39;variable&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="p">(</span><span class="n">base_model</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">true_sample</span><span class="p">,</span> <span class="n">noiseless_obs</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">obs_indices</span><span class="p">,</span>
     <span class="n">obs_model</span><span class="p">,</span> <span class="n">kle</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span> <span class="o">=</span> <span class="n">_setup_inverse_advection_diffusion_benchmark</span><span class="p">(</span>
         <span class="n">source_amp</span><span class="p">,</span> <span class="n">source_width</span><span class="p">,</span> <span class="n">source_loc</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="n">noise_stdev</span><span class="p">,</span>
         <span class="n">kle_length_scale</span><span class="p">,</span> <span class="n">kle_stdev</span><span class="p">,</span> <span class="n">kle_nvars</span><span class="p">,</span> <span class="n">orders</span><span class="p">,</span> <span class="n">obs_indices</span><span class="p">)</span>
    <span class="c1"># add wrapper to allow execution times to be captured</span>
    <span class="n">timer_model</span> <span class="o">=</span> <span class="n">TimerModel</span><span class="p">(</span><span class="n">base_model</span><span class="p">,</span> <span class="n">base_model</span><span class="p">)</span>
    <span class="n">pool_model</span> <span class="o">=</span> <span class="n">PoolModel</span><span class="p">(</span>
        <span class="n">timer_model</span><span class="p">,</span> <span class="n">max_eval_concurrency</span><span class="p">,</span> <span class="n">base_model</span><span class="o">=</span><span class="n">base_model</span><span class="p">)</span>

    <span class="c1"># add wrapper that tracks execution times.</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">WorkTrackingModel</span><span class="p">(</span><span class="n">pool_model</span><span class="p">,</span> <span class="n">base_model</span><span class="p">)</span>

    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;negloglike&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span>
                  <span class="s2">&quot;noiseless_obs&quot;</span><span class="p">:</span> <span class="n">noiseless_obs</span><span class="p">,</span> <span class="s2">&quot;obs&quot;</span><span class="p">:</span> <span class="n">obs</span><span class="p">,</span>
                  <span class="s2">&quot;true_sample&quot;</span><span class="p">:</span> <span class="n">true_sample</span><span class="p">,</span> <span class="s2">&quot;obs_indices&quot;</span><span class="p">:</span> <span class="n">obs_indices</span><span class="p">,</span>
                  <span class="s2">&quot;obs_fun&quot;</span><span class="p">:</span> <span class="n">obs_model</span><span class="p">,</span> <span class="s2">&quot;KLE&quot;</span><span class="p">:</span> <span class="n">kle</span><span class="p">,</span> <span class="s2">&quot;mesh&quot;</span><span class="p">:</span> <span class="n">mesh</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Benchmark</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span></div>


<span class="n">_benchmarks</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;sobol_g&#39;</span><span class="p">:</span> <span class="n">setup_sobol_g_function</span><span class="p">,</span>
    <span class="s1">&#39;ishigami&#39;</span><span class="p">:</span> <span class="n">setup_ishigami_function</span><span class="p">,</span>
    <span class="s1">&#39;oakley&#39;</span><span class="p">:</span> <span class="n">setup_oakley_function</span><span class="p">,</span>
    <span class="s1">&#39;rosenbrock&#39;</span><span class="p">:</span> <span class="n">setup_rosenbrock_function</span><span class="p">,</span>
    <span class="s1">&#39;genz&#39;</span><span class="p">:</span> <span class="n">setup_genz_function</span><span class="p">,</span>
    <span class="s1">&#39;cantilever_beam&#39;</span><span class="p">:</span> <span class="n">setup_cantilever_beam_benchmark</span><span class="p">,</span>
    <span class="s1">&#39;wing_weight&#39;</span><span class="p">:</span> <span class="n">setup_wing_weight_benchmark</span><span class="p">,</span>
    <span class="s1">&#39;piston&#39;</span><span class="p">:</span> <span class="n">setup_piston_benchmark</span><span class="p">,</span>
    <span class="s1">&#39;chemical_reaction&#39;</span><span class="p">:</span> <span class="n">setup_chemical_reaction_benchmark</span><span class="p">,</span>
    <span class="s1">&#39;random_oscillator&#39;</span><span class="p">:</span> <span class="n">setup_random_oscillator_benchmark</span><span class="p">,</span>
    <span class="s1">&#39;coupled_springs&#39;</span><span class="p">:</span> <span class="n">setup_coupled_springs_benchmark</span><span class="p">,</span>
    <span class="s1">&#39;hastings_ecology&#39;</span><span class="p">:</span> <span class="n">setup_hastings_ecology_benchmark</span><span class="p">,</span>
    <span class="s1">&#39;multi_index_advection_diffusion&#39;</span><span class="p">:</span>
    <span class="n">setup_multi_index_advection_diffusion_benchmark</span><span class="p">,</span>
    <span class="s1">&#39;advection_diffusion_kle_inversion&#39;</span><span class="p">:</span>
    <span class="n">setup_advection_diffusion_kle_inversion_benchmark</span><span class="p">,</span>
    <span class="s1">&#39;polynomial_ensemble&#39;</span><span class="p">:</span> <span class="n">setup_polynomial_ensemble</span><span class="p">,</span>
    <span class="s1">&#39;tunable_model_ensemble&#39;</span><span class="p">:</span> <span class="n">setup_tunable_model_ensemble</span><span class="p">,</span>
    <span class="s1">&#39;short_column_ensemble&#39;</span><span class="p">:</span> <span class="n">setup_short_column_ensemble</span><span class="p">,</span>
    <span class="s2">&quot;parameterized_nonlinear_model&quot;</span><span class="p">:</span> <span class="n">setup_parameterized_nonlinear_model</span><span class="p">}</span>


<div class="viewcode-block" id="setup_benchmark"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.setup_benchmark.html#pyapprox.benchmarks.setup_benchmark">[docs]</a><span class="k">def</span> <span class="nf">setup_benchmark</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup a PyApprox benchmark.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : string</span>
<span class="sd">        The name of the benchmark</span>

<span class="sd">    kwargs: kwargs</span>
<span class="sd">     optional keyword arguments</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    benchmark : :py:class:`~pyapprox.benchmarks.Benchmark`</span>
<span class="sd">       Object containing the benchmark attributes</span>

<span class="sd">    The benchmark object must contain at least the following two attributes</span>

<span class="sd">    fun : callable</span>
<span class="sd">        A function with signature</span>

<span class="sd">        fun(samples) -&gt; np.ndarray(nsamples, nqoi)</span>

<span class="sd">        where samples : np.ndarray(nvars, nsamples)</span>

<span class="sd">    variable : :py:class:`~pyapprox.variables.JointVariable`</span>
<span class="sd">        Class containing information about each of the nvars inputs to fun</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_benchmarks</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Benchmark &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; not found.</span><span class="se">\n</span><span class="s1"> Available benchmarks are:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_benchmarks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_benchmarks</span><span class="p">[</span><span class="n">name</span><span class="p">](</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="list_benchmarks"><a class="viewcode-back" href="../../../api/pyapprox.benchmarks.list_benchmarks.html#pyapprox.benchmarks.list_benchmarks">[docs]</a><span class="k">def</span> <span class="nf">list_benchmarks</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List the names of all available benchmarks</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    names : list</span>
<span class="sd">        A list of the name of each benchmark implemented in PyApprox</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">_benchmarks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019 National Technology &amp; Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>