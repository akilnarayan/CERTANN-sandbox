<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyapprox.multifidelity.control_variate_monte_carlo &mdash; PyApprox 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> PyApprox
            <img src="../../../_static/pyapprox-logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Software Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_tutorials/index.html">Theoretical Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Benchmarks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../benchmarks.html">Benchmarks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Reference Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_reference_guide.html">User Reference Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyApprox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>pyapprox.multifidelity.control_variate_monte_carlo</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyapprox.multifidelity.control_variate_monte_carlo</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions for estimating expectations using frequentist control-variate</span>
<span class="sd">Monte-Carlo based methods such as multi-level Monte-Carlo,</span>
<span class="sd">control-variate Monte-Carlo, and approximate control-variate Monte-Carlo.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>


<span class="kn">from</span> <span class="nn">pyapprox.variables.sampling</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">generate_independent_random_samples</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.util.utilities</span> <span class="kn">import</span> <span class="n">get_all_sample_combinations</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># use torch to compute gradients for sample allocation optimization</span>
    <span class="kn">import</span> <span class="nn">torch</span>
    <span class="n">use_torch</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">pkg</span> <span class="o">=</span> <span class="n">torch</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># msg = &#39;Could not import Torch&#39;</span>
    <span class="c1"># print(msg)</span>
    <span class="n">use_torch</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">pkg</span> <span class="o">=</span> <span class="n">np</span>
<span class="c1"># use_torch = False</span>
<span class="c1"># pkg = np</span>


<span class="k">def</span> <span class="nf">_ndarray_as_pkg_format</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shallow copy an np.ndarray to the format used by pkg, e.g.</span>
<span class="sd">    either np.ndarray or torch.tensor. If already in the correct format</span>
<span class="sd">    a reference to the original object will be returned</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_torch</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pkg</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pkg</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">use_torch</span> <span class="ow">and</span> <span class="n">pkg</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array</span>
    <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">use_torch</span> <span class="ow">and</span> <span class="n">pkg</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">pkg_copy</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">use_torch</span> <span class="ow">and</span> <span class="n">pkg</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">pkg_hstack</span><span class="p">(</span><span class="n">objs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">use_torch</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">pkg</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">pkg</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pkg_zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_type</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">array_type</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pkg</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pkg_ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_type</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">array_type</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pkg</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pkg_empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_type</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">array_type</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pkg</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pkg_diff</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">use_torch</span> <span class="ow">and</span> <span class="n">pkg</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pkg</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pkg_solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">use_torch</span> <span class="ow">and</span> <span class="n">pkg</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pkg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">check_safe_cast_to_integers</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">array_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">array_int</span><span class="p">,</span> <span class="mf">1e-15</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arrays entries are not integers&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array_int</span>


<span class="k">def</span> <span class="nf">cast_to_integers</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">check_safe_cast_to_integers</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">compute_correlations_from_covariance</span><span class="p">(</span><span class="n">cov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the correlation matrix of a covariance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The covariance C between each of the models. The highest fidelity</span>
<span class="sd">        model is the first model, i.e its variance is cov[0,0]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    corr : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The correlation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">corr_sqrt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">))))</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">corr_sqrt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">corr_sqrt</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">corr</span>


<span class="k">def</span> <span class="nf">get_variance_reduction</span><span class="p">(</span><span class="n">get_rsquared</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the variance reduction:</span>

<span class="sd">    .. math:: \gamma = 1-r^2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The covariance C between each of the models. The highest fidelity</span>
<span class="sd">        model is the first model, i.e its variance is cov[0,0]</span>

<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of samples of the</span>
<span class="sd">        lower fidelity models, e.g. N_i = r_i*nhf_samples, i=1,...,nmodels-1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gamma : float</span>
<span class="sd">        The variance reduction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">-</span><span class="n">get_rsquared</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_control_variate_rsquared</span><span class="p">(</span><span class="n">cov</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute :math:`r^2` used to compute the variance reduction of</span>
<span class="sd">    control variate Monte Carlo</span>

<span class="sd">    .. math:: \gamma = 1-r^2, \qquad     r^2 = c^TC^{-1}c</span>

<span class="sd">    where c is the first column of C</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The covariance C between each of the models. The highest fidelity</span>
<span class="sd">        model is the first model, i.e its variance is cov[0,0]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rsquared : float</span>
<span class="sd">        The value  :math:`r^2`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># nmodels = cov.shape[0]</span>
    <span class="n">rsquared</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pkg_solve</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="n">rsquared</span> <span class="o">/=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rsquared</span>


<span class="k">def</span> <span class="nf">get_rsquared_mfmc</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute r^2 used to compute the variance reduction  of</span>
<span class="sd">    Multifidelity Monte Carlo (MFMC)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The covariance C between each of the models. The highest fidelity</span>
<span class="sd">        model is the first model, i.e its variance is cov[0,0]</span>

<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of samples of the</span>
<span class="sd">        lower fidelity models, e.g. N_i = r_i*nhf_samples, i=1,...,nmodels-1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rsquared : float</span>
<span class="sd">        The value r^2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">)</span> <span class="o">==</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">rsquared</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span>
        <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span>
            <span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">p1</span> <span class="o">*=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rsquared</span> <span class="o">+=</span> <span class="n">p1</span>
    <span class="k">return</span> <span class="n">rsquared</span>


<span class="k">def</span> <span class="nf">get_rsquared_mlmc</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute r^2 used to compute the variance reduction of</span>
<span class="sd">    Multilevel Monte Carlo (MLMC)</span>

<span class="sd">    See Equation 2.24 in ARXIV paper where alpha_i=-1 for all i</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The covariance C between each of the models. The highest fidelity</span>
<span class="sd">        model is the first model, i.e its variance is cov[0,0]</span>

<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of samples of the</span>
<span class="sd">        lower fidelity models, e.g. N_i = r_i*nhf_samples,</span>
<span class="sd">        i=1,...,nmodels-1.</span>
<span class="sd">        The values r_i correspond to eta_i in Equation 2.24</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gamma : float</span>
<span class="sd">        The variance reduction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">)</span> <span class="o">==</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">rhat</span> <span class="o">=</span> <span class="n">pkg_ones</span><span class="p">((</span><span class="n">nmodels</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">cov</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">rhat</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rhat</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">vardelta</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gamma</span> <span class="o">+=</span> <span class="n">vardelta</span> <span class="o">/</span> <span class="p">(</span><span class="n">rhat</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">gamma</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="n">rhat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">gamma</span> <span class="o">/=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">-</span><span class="n">gamma</span>


<span class="k">def</span> <span class="nf">get_mlmc_control_variate_weights</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the weights used by the MLMC control variate estimator</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray (nmodels-1)</span>
<span class="sd">        The control variate weights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">compute_approximate_control_variate_mean_estimate</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use approximate control variate Monte Carlo to estimate the mean of</span>
<span class="sd">    high-fidelity data with low-fidelity models with unknown means</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : list (nmodels)</span>
<span class="sd">        Each entry of the list contains</span>

<span class="sd">        values0 : np.ndarray (num_samples_i0,num_qoi)</span>
<span class="sd">           Evaluations  of each model</span>
<span class="sd">           used to compute the estimator :math:`Q_{i,N}` of</span>

<span class="sd">        values1: np.ndarray (num_samples_i1,num_qoi)</span>
<span class="sd">            Evaluations used compute the approximate</span>
<span class="sd">            mean :math:`\mu_{i,r_iN}` of the low fidelity models.</span>

<span class="sd">    weights : np.ndarray (nmodels-1)</span>
<span class="sd">        the control variate weights</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    est : float</span>
<span class="sd">        The control variate estimate of the mean</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="n">nmodels</span>
    <span class="c1"># high fidelity monte carlo estimate of mean</span>
    <span class="n">est</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">est</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">-</span><span class="n">values</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">est</span>


<span class="k">def</span> <span class="nf">compute_control_variate_mean_estimate</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">lf_means</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use control variate Monte Carlo to estimate the mean of</span>
<span class="sd">    high-fidelity data with low-fidelity models with known means</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : list (nmodels)</span>
<span class="sd">        Each entry of the list contains</span>

<span class="sd">        values0 : np.ndarray (num_samples_i0,num_qoi)</span>
<span class="sd">           Evaluations  of each model</span>
<span class="sd">           used to compute the estimator :math:`Q_{i,N}` of</span>

<span class="sd">    weights : np.ndarray (nmodels-1)</span>
<span class="sd">        the control variate weights</span>


<span class="sd">    lf_means : np.ndarray (nmodels-1):</span>
<span class="sd">        The known means of the low fidelity models</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    est : float</span>
<span class="sd">        The control variate estimate of the mean</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="n">nmodels</span>
    <span class="c1"># high fidelity monte carlo estimate of mean</span>
    <span class="n">est</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">est</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">-</span><span class="n">lf_means</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">est</span>


<span class="k">def</span> <span class="nf">check_mfmc_model_costs_and_correlations</span><span class="p">(</span><span class="n">costs</span><span class="p">,</span> <span class="n">corr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check that the model costs and correlations satisfy equation 3.12</span>
<span class="sd">    in MFMC paper.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">denom</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">corr_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">denom</span>
        <span class="n">cost_ratio</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">costs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">corr_ratio</span> <span class="o">&gt;=</span> <span class="n">cost_ratio</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">allocate_samples_mfmc</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the samples to be allocated to each model when using MFMC</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The covariance C between each of the models. The highest fidelity</span>
<span class="sd">        model is the first model, i.e its variance is cov[0,0]</span>

<span class="sd">    costs : np.ndarray (nmodels)</span>
<span class="sd">        The relative costs of evaluating each model</span>

<span class="sd">    target_cost : float</span>
<span class="sd">        The total cost budget</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of samples of the</span>
<span class="sd">        lower fidelity models, e.g. N_i=r_i*nhf_samples, i=1,...,nmodels-1</span>

<span class="sd">    log10_variance : float</span>
<span class="sd">        The base 10 logarithm of the variance of the estimator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">compute_correlations_from_covariance</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">II</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">II</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Models must be ordered with decreasing correlation with &#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;high-fidelity model&#39;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Step 3 in Algorithm 2 in Peherstorfer et al 2016</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">))</span>

    <span class="n">num</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">corr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">))</span>

    <span class="c1"># Step 4 in Algorithm 2 in Peherstorfer et al 2016</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">target_cost</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">costs</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="c1"># nhf_samples = max(nhf_samples, 1)</span>
    <span class="n">nsample_ratios</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">gamma</span> <span class="o">=</span> <span class="n">get_variance_reduction</span><span class="p">(</span><span class="n">get_rsquared_mfmc</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">)</span>
    <span class="n">log10_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
        <span class="n">nhf_samples</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">),</span> <span class="n">log10_variance</span>


<span class="k">def</span> <span class="nf">allocate_samples_mlmc</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the samples to be allocated to each model when using MLMC</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The covariance C between each of the models. The highest fidelity</span>
<span class="sd">        model is the first model, i.e its variance is cov[0,0]</span>

<span class="sd">    costs : np.ndarray (nmodels)</span>
<span class="sd">        The relative costs of evaluating each model</span>

<span class="sd">    target_cost : float</span>
<span class="sd">        The total cost budget</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nhf_samples : integer</span>
<span class="sd">        The number of samples of the high fidelity model</span>

<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of samples of the</span>
<span class="sd">        lower fidelity models, e.g. N_i = r_i*nhf_samples,</span>
<span class="sd">        i=1,...,nmodels-1. For model i&gt;0 nsample_ratio*nhf_samples equals</span>
<span class="sd">        the number of samples in the two different discrepancies involving</span>
<span class="sd">        the ith model.</span>

<span class="sd">    log10_variance : float</span>
<span class="sd">        The base 10 logarithm of the variance of the estimator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>

    <span class="n">II</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">costs</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">II</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nmodels</span><span class="p">)):</span>
        <span class="c1"># print(costs)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Models cost do not decrease monotonically&quot;</span><span class="p">)</span>

    <span class="c1"># compute the variance of the discrepancy</span>
    <span class="n">var_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nmodels</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">var_deltas</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">var_deltas</span><span class="p">[</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># compute the cost of one sample of the discrepancy</span>
    <span class="n">cost_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nmodels</span><span class="p">)</span>
    <span class="n">cost_deltas</span><span class="p">[:</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">costs</span><span class="p">[:</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nmodels</span><span class="p">])</span>
    <span class="n">cost_deltas</span><span class="p">[</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># compute variance * cost</span>
    <span class="n">var_cost_prods</span> <span class="o">=</span> <span class="n">var_deltas</span> <span class="o">*</span> <span class="n">cost_deltas</span>

    <span class="c1"># compute variance / cost</span>
    <span class="n">var_cost_ratios</span> <span class="o">=</span> <span class="n">var_deltas</span> <span class="o">/</span> <span class="n">cost_deltas</span>

    <span class="c1"># compute the lagrange multiplier</span>
    <span class="n">lagrange_multiplier</span> <span class="o">=</span> <span class="n">target_cost</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_cost_prods</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># compute the number of samples needed for each discrepancy</span>
    <span class="n">nsamples_per_delta</span> <span class="o">=</span> <span class="n">lagrange_multiplier</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_cost_ratios</span><span class="p">)</span>

    <span class="c1"># compute the ML estimator variance from the target cost</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">var_deltas</span><span class="o">/</span><span class="n">nsamples_per_delta</span><span class="p">)</span>

    <span class="c1"># compute the number of samples allocated to each model. For</span>
    <span class="c1"># all but the highest fidelity model we need to collect samples</span>
    <span class="c1"># from two discrepancies.</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">nsamples_per_delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nsample_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">nsamples_per_delta</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">+</span><span class="n">nsamples_per_delta</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">nhf_samples</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
        <span class="n">nhf_samples</span><span class="o">*</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nsample_ratios</span><span class="o">*</span><span class="n">nhf_samples</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
        <span class="n">cost_deltas</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nsamples_per_delta</span><span class="p">))</span>

    <span class="n">gamma</span> <span class="o">=</span> <span class="n">get_variance_reduction</span><span class="p">(</span><span class="n">get_rsquared_mlmc</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">)</span>
    <span class="n">log10_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
        <span class="n">nhf_samples</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">log10_variance</span><span class="p">))</span>
    <span class="c1"># print(log10_variance)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">log10_variance</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;MLMC variance is NAN&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">),</span> <span class="n">log10_variance</span>


<span class="k">def</span> <span class="nf">get_lagrange_multiplier_mlmc</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an optimal sample allocation recover the optimal value of the</span>
<span class="sd">    Lagrange multiplier. This is only used for testing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">var_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nmodels</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">var_deltas</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">var_deltas</span><span class="p">[</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cost_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nmodels</span><span class="p">)</span>
    <span class="n">cost_deltas</span><span class="p">[:</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">costs</span><span class="p">[:</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nmodels</span><span class="p">])</span>
    <span class="n">cost_deltas</span><span class="p">[</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">var_cost_prods</span> <span class="o">=</span> <span class="n">var_deltas</span> <span class="o">*</span> <span class="n">cost_deltas</span>
    <span class="n">lagrange_mult</span> <span class="o">=</span> <span class="n">target_cost</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_cost_prods</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">lagrange_mult</span>


<span class="k">def</span> <span class="nf">get_discrepancy_covariances_IS</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the covariances of the discrepancies :math:`\delta`</span>
<span class="sd">    between each low-fidelity model and its estimated mean when the same</span>
<span class="sd">    :math:`N` samples are used to compute the covariance between each models</span>
<span class="sd">    and :math:`N-r_\alpha` samples are allocated to</span>
<span class="sd">    estimate the low-fidelity means, and each of these sets are drawn</span>
<span class="sd">    independently from one another.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The estimated covariance between each model.</span>

<span class="sd">    nsample_ratios : iterable (nmodels-1)</span>
<span class="sd">        The sample ratioss :math:`r_\alpha&gt;1` for each low-fidelity model</span>

<span class="sd">    Results</span>
<span class="sd">    -------</span>
<span class="sd">    CF : np.ndarray (nmodels-1,nmodels-1)</span>
<span class="sd">        The matrix of covariances between the discrepancies :math:`\delta`</span>

<span class="sd">    cf : np.ndarray (nmodels-1)</span>
<span class="sd">        The vector of covariances between the discrepancies and the</span>
<span class="sd">        high-fidelity model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">((</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">nsample_ratios</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="n">F</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
        <span class="n">f</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span>

    <span class="n">CF</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">F</span>
    <span class="n">cf</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">CF</span><span class="p">,</span> <span class="n">cf</span>


<span class="k">def</span> <span class="nf">get_discrepancy_covariances_MF</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the covariances of the discrepancies :math:`\delta`</span>
<span class="sd">    between each low-fidelity model and its estimated mean using the MFMC</span>
<span class="sd">    sampling strategy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The estimated covariance between each model.</span>

<span class="sd">    nsample_ratios : iterable (nmodels-1)</span>
<span class="sd">        The sample ratioss :math:`r_\alpha&gt;1` for each low-fidelity model</span>

<span class="sd">    Results</span>
<span class="sd">    -------</span>
<span class="sd">    CF : np.ndarray (nmodels-1,nmodels-1)</span>
<span class="sd">        The matrix of covariances between the discrepancies :math:`\delta`</span>

<span class="sd">    cf : np.ndarray (nmodels-1)</span>
<span class="sd">        The vector of covariances between the discrepancies and the</span>
<span class="sd">        high-fidelity model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">rr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">nsample_ratios</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
            <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">rr</span>
        <span class="n">f</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span>
    <span class="n">CF</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">F</span>
    <span class="n">cf</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">CF</span><span class="p">,</span> <span class="n">cf</span>


<span class="k">def</span> <span class="nf">get_discrepancy_covariances_KL</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the covariances of the discrepancies :math:`\delta`</span>
<span class="sd">    between each low-fidelity model and its estimated mean using the MFMC</span>
<span class="sd">    sampling strategy and the ACV KL estimator.</span>

<span class="sd">    The ACV-KL estimator partitions all of the control variates into two</span>
<span class="sd">    groups; the first K variables form a K -level approximate control</span>
<span class="sd">    variate, and the last :math:`M-K` variables are used to reduce the variance</span>
<span class="sd">    of estimating :math:`\mu_L` some :math:`L \le K` . The resulting estimator</span>
<span class="sd">    accelerates convergence to OCV-K , and L provides a degree of freedom</span>
<span class="sd">    for targeting a control variate level that contributes the greatest to</span>
<span class="sd">    the estimator variance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The estimated covariance between each model.</span>

<span class="sd">    nsample_ratios : iterable (nmodels-1)</span>
<span class="sd">        The sample ratioss :math:`r_\alpha&gt;1` for each low-fidelity model</span>

<span class="sd">    K : integer (K&lt;=nmodels-1)</span>
<span class="sd">        The number of effective control variates.</span>

<span class="sd">    L : integer (1&lt;=L&lt;=K+1)</span>
<span class="sd">        The id of the models whose mean is being targeted by the</span>
<span class="sd">        remaining nmodels-K low fidelity models.</span>

<span class="sd">    Results</span>
<span class="sd">    -------</span>
<span class="sd">    CF : np.ndarray (nmodels-1,nmodels-1)</span>
<span class="sd">        The matrix of covariances between the discrepancies :math:`\delta`</span>

<span class="sd">    cf : np.ndarray (nmodels-1)</span>
<span class="sd">        The vector of covariances between the discrepancies and the</span>
<span class="sd">        high-fidelity model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">L</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="n">nmodels</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">nsample_ratios</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Diagonal terms</span>
        <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">:</span>
            <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">+</span><span class="mf">1e-20</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">])</span>
        <span class="c1"># Off-diagonal terms</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">):</span>
                <span class="n">ri</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">rs</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
                <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ri</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ri</span> <span class="o">+</span> <span class="mf">1e-20</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">jj</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">):</span>
                <span class="n">ri</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">rs</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">-</span><span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="n">rs</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">*</span><span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">]</span>
                                                    <span class="o">+</span> <span class="mf">1e-20</span><span class="p">)</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ri</span> <span class="o">-</span> <span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">rs</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-20</span><span class="p">)</span>
                <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">jj</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">):</span>
                <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-20</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">jj</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">):</span>
                <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">*</span> <span class="n">rs</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-20</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">F</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
        <span class="n">f</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span>

    <span class="n">CF</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">F</span>
    <span class="n">cf</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">CF</span><span class="p">,</span> <span class="n">cf</span>


<span class="k">def</span> <span class="nf">get_control_variate_weights</span><span class="p">(</span><span class="n">cov</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the weights used by the control variate estimator with known low</span>
<span class="sd">    fidelity means.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The estimated covariance between each model.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray (nmodels-1)</span>
<span class="sd">        The control variate weights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">weights</span>


<span class="k">def</span> <span class="nf">get_approximate_control_variate_weights</span><span class="p">(</span><span class="n">CF</span><span class="p">,</span> <span class="n">cf</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the weights used by the approximate control variate estimator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    CF : np.ndarray (nmodels-1,nmodels-1)</span>
<span class="sd">        The matrix of covariances between the discrepancies :math:`\delta`</span>

<span class="sd">    cf : np.ndarray (nmodels-1)</span>
<span class="sd">        The vector of covariances between the discrepancies and the</span>
<span class="sd">        high-fidelity model.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : np.ndarray (nmodels-1)</span>
<span class="sd">        The control variate weights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">CF</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">CF</span><span class="p">,</span> <span class="n">cf</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="o">-</span><span class="n">pkg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">CF</span><span class="p">,</span> <span class="n">cf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weights</span>


<span class="k">def</span> <span class="nf">get_rsquared_acv</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">,</span> <span class="n">get_discrepancy_covariances</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute r^2 used to compute the variance reduction of</span>
<span class="sd">    Approximate Control Variate Algorithms</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The covariance C between each of the models. The highest fidelity model</span>
<span class="sd">        is the first model, i.e its variance is cov[0,0]</span>

<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of samples of the</span>
<span class="sd">        lower fidelity models, e.g. N_i = r_i*nhf_samples, i=1,...,nmodels-1</span>

<span class="sd">    get_discrepancy_covariances : callable</span>
<span class="sd">        Function that returns the covariances of the control variate</span>
<span class="sd">        discrepancies. Functions must have the signature</span>
<span class="sd">        CF,cf = get_discrepancy_covariances(cov,nsample_ratios)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rsquared : float</span>
<span class="sd">        The value r^2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CF</span><span class="p">,</span> <span class="n">cf</span> <span class="o">=</span> <span class="n">get_discrepancy_covariances</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">get_approximate_control_variate_weights</span><span class="p">(</span><span class="n">CF</span><span class="p">,</span> <span class="n">cf</span><span class="p">)</span>
        <span class="n">rsquared</span> <span class="o">=</span> <span class="o">-</span><span class="n">cf</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">/</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="n">rsquared</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-16</span>
    <span class="k">return</span> <span class="n">rsquared</span>


<span class="k">def</span> <span class="nf">acv_sample_allocation_gmf_ratio_constraint</span><span class="p">(</span><span class="n">ratios</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">model_idx</span><span class="p">,</span> <span class="n">parent_idx</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">assert</span> <span class="n">parent_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">model_idx</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">get_nhf_samples</span><span class="p">(</span><span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">ratios</span><span class="p">)</span>
    <span class="c1"># ratios are only for low-fidelity models so use index-1</span>
    <span class="c1"># return nhf_samples*(ratios[model_idx-1]-ratios[parent_idx-1])-(1+eps)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">nhf_samples</span><span class="o">*</span><span class="n">ratios</span><span class="p">[</span><span class="n">model_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">nhf_samples</span><span class="o">*</span><span class="n">ratios</span><span class="p">[</span><span class="n">parent_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
            <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">eps</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">acv_sample_allocation_gmf_ratio_constraint_jac</span><span class="p">(</span><span class="n">ratios</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">model_idx</span><span class="p">,</span> <span class="n">parent_idx</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">assert</span> <span class="n">parent_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">model_idx</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">get_nhf_samples</span><span class="p">(</span>
        <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">ratios</span><span class="p">)</span>
    <span class="c1"># ratios are only for low-fidelity models so use index-1</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="o">-</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">*</span><span class="n">nhf_samples</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">target_cost</span><span class="o">*</span><span class="p">(</span>
        <span class="n">ratios</span><span class="p">[</span><span class="n">model_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ratios</span><span class="p">[</span><span class="n">parent_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">grad</span><span class="p">[</span><span class="n">model_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nhf_samples</span>
    <span class="n">grad</span><span class="p">[</span><span class="n">parent_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">nhf_samples</span>
    <span class="k">return</span> <span class="n">grad</span>


<span class="k">def</span> <span class="nf">acv_sample_allocation_nlf_gt_nhf_ratio_constraint</span><span class="p">(</span><span class="n">ratios</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">model_idx</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">assert</span> <span class="n">model_idx</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">get_nhf_samples</span><span class="p">(</span><span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">ratios</span><span class="p">)</span>
    <span class="c1"># print(model_idx, nhf_samples)</span>
    <span class="c1"># ratios are only for low-fidelity models so use index-1</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">nhf_samples</span><span class="o">*</span><span class="n">ratios</span><span class="p">[</span><span class="n">model_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">nhf_samples</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">eps</span><span class="p">)</span>
    <span class="c1"># print(val)</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">acv_sample_allocation_nlf_gt_nhf_ratio_constraint_jac</span><span class="p">(</span><span class="n">ratios</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">model_idx</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">assert</span> <span class="n">model_idx</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">get_nhf_samples</span><span class="p">(</span>
        <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">ratios</span><span class="p">)</span>
    <span class="c1"># ratios are only for low-fidelity models so use index-1</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="o">-</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">*</span><span class="n">nhf_samples</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">target_cost</span><span class="o">*</span><span class="p">(</span><span class="n">ratios</span><span class="p">[</span><span class="n">model_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">grad</span><span class="p">[</span><span class="n">model_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nhf_samples</span>
    <span class="k">return</span> <span class="n">grad</span>


<span class="k">def</span> <span class="nf">acv_sample_allocation_nhf_samples_constraint</span><span class="p">(</span><span class="n">ratios</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span> <span class="o">=</span> <span class="n">args</span>
    <span class="c1"># add to ensure that when constraint is violated by small numerical value</span>
    <span class="c1"># nhf samples generated from ratios will be greater than 1</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">get_nhf_samples</span><span class="p">(</span><span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">ratios</span><span class="p">)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">nhf_samples</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">eps</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">acv_sample_allocation_nhf_samples_constraint_jac</span><span class="p">(</span><span class="n">ratios</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span> <span class="o">=</span> <span class="n">args</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">get_nhf_samples</span><span class="p">(</span>
        <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">ratios</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="o">-</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">*</span><span class="n">nhf_samples</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">target_cost</span>
    <span class="k">return</span> <span class="n">grad</span>


<span class="k">def</span> <span class="nf">generate_samples_and_values_acv_IS</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">,</span>
                                       <span class="n">functions</span><span class="p">,</span> <span class="n">generate_samples</span><span class="p">):</span>
    <span class="c1"># nmodels = len(nsample_ratios)+1</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">functions</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span> <span class="o">==</span> <span class="n">nmodels</span>
    <span class="n">samples1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">generate_samples</span><span class="p">(</span><span class="n">nhf_samples</span><span class="p">)]</span><span class="o">*</span><span class="n">nmodels</span>
    <span class="n">samples2</span> <span class="o">=</span> <span class="p">[</span><span class="n">samples1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">+</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
         <span class="p">[</span><span class="n">samples1</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">generate_samples</span><span class="p">(</span>
             <span class="nb">int</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">nhf_samples</span><span class="p">))])</span>
         <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">)]</span>

    <span class="n">values2</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">samples2</span><span class="p">)]</span>
    <span class="n">values1</span> <span class="o">=</span> <span class="p">[</span><span class="n">functions</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">samples2</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">values1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">values2</span><span class="p">[</span><span class="n">ii</span><span class="p">][:</span><span class="n">nhf_samples</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">)]</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]</span> <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">samples1</span><span class="p">,</span> <span class="n">samples2</span><span class="p">)]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">]</span> <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values1</span><span class="p">,</span> <span class="n">values2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">generate_samples_and_values_mlmc</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">,</span> <span class="n">functions</span><span class="p">,</span>
                                     <span class="n">generate_samples</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nsamples_per_model : np.ndarray (nsamples)</span>
<span class="sd">            The number of samples allocated to each model</span>

<span class="sd">    functions : list of callables</span>
<span class="sd">        The functions used to evaluate each model</span>

<span class="sd">    generate_samples : callable</span>
<span class="sd">        Function used to generate realizations of the random variables</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples : list</span>
<span class="sd">        List containing the samples :math:`\mathcal{Z}_{i,1}` and</span>
<span class="sd">        :math:`\mathcal{Z}_{i,2}` for each model :math:`i=0,\ldots,M-1`.</span>
<span class="sd">        The list is [[:math:`\mathcal{Z}_{0,1}`,:math:`\mathcal{Z}_{0,2}`],...,[:math:`\mathcal{Z}_{M-1,1}`,:math:`\mathcal{Z}_{M-1,2}`]],</span>
<span class="sd">        where :math:`M` is the number of models</span>

<span class="sd">    values : list</span>
<span class="sd">        Model values at the points in samples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">nmodels</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">samples1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">samples2</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_samples</span><span class="p">(</span><span class="n">nhf_samples</span><span class="p">)]</span>
    <span class="n">prev_samples</span> <span class="o">=</span> <span class="n">samples2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># total_samples = nsample_ratios[ii] * nhf_samples</span>
        <span class="n">total_samples</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">total_samples</span><span class="o">/</span><span class="nb">int</span><span class="p">(</span><span class="n">total_samples</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span>
        <span class="n">total_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_samples</span><span class="p">)</span>
        <span class="n">samples1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_samples</span><span class="p">)</span>
        <span class="n">nnew_samples</span> <span class="o">=</span> <span class="n">total_samples</span> <span class="o">-</span> <span class="n">prev_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">samples2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_samples</span><span class="p">(</span><span class="n">nnew_samples</span><span class="p">))</span>
        <span class="n">prev_samples</span> <span class="o">=</span> <span class="n">samples2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">values2</span> <span class="o">=</span> <span class="p">[</span><span class="n">functions</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">samples2</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">values1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">values1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">functions</span><span class="p">[</span><span class="n">ii</span><span class="p">](</span><span class="n">samples1</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>
        <span class="n">values2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">functions</span><span class="p">[</span><span class="n">ii</span><span class="p">](</span><span class="n">samples2</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]</span> <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">samples1</span><span class="p">,</span> <span class="n">samples2</span><span class="p">)]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">]</span> <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values1</span><span class="p">,</span> <span class="n">values2</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">get_mfmc_control_variate_weights</span><span class="p">(</span><span class="n">cov</span><span class="p">):</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="o">-</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">weights</span>


<span class="k">def</span> <span class="nf">generate_samples_and_values_acv_KL</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">,</span> <span class="n">functions</span><span class="p">,</span>
                                       <span class="n">generate_samples</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    K : integer (K&lt;=nmodels-1)</span>
<span class="sd">        The number of effective control variates.</span>

<span class="sd">    L : integer (1&lt;=L&lt;=K+1)</span>
<span class="sd">        The id of the models whose mean is being targeted by the</span>
<span class="sd">        remaining nmodels-K low fidelity models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># nsample_ratios = np.asarray(nsample_ratios)</span>
    <span class="c1"># nlf_samples = validate_nsample_ratios(nhf_samples, nsample_ratios)</span>
    <span class="c1"># nmodels = nsample_ratios.shape[0]+1</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nhf_samples</span><span class="p">,</span> <span class="n">nlf_samples</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">assert</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">L</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="n">nmodels</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">max_nsamples</span> <span class="o">=</span> <span class="n">nlf_samples</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">generate_samples</span><span class="p">(</span><span class="n">max_nsamples</span><span class="p">)</span>
    <span class="n">samples1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">samples2</span> <span class="o">=</span> <span class="p">[</span><span class="n">samples</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nhf_samples</span><span class="p">]]</span>
    <span class="n">nprev_samples1</span> <span class="o">=</span> <span class="n">nhf_samples</span>
    <span class="c1"># nprev_samples_total = nhf_samples</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">samples1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nprev_samples1</span><span class="p">])</span>
        <span class="n">samples2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nlf_samples</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">):</span>
            <span class="n">nprev_samples1</span> <span class="o">=</span> <span class="n">nhf_samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nprev_samples1</span> <span class="o">=</span> <span class="n">nlf_samples</span><span class="p">[</span><span class="n">L</span><span class="p">]</span>
        <span class="c1"># nprev_samples_total = nlf_samples[ii-1]</span>

    <span class="n">values2</span> <span class="o">=</span> <span class="p">[</span><span class="n">functions</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">samples1</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">values1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">values_ii</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">ii</span><span class="p">](</span><span class="n">samples2</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        <span class="n">values1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values_ii</span><span class="p">[:</span><span class="n">samples1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">values2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values_ii</span><span class="p">)</span>

    <span class="n">samples</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]</span> <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">samples1</span><span class="p">,</span> <span class="n">samples2</span><span class="p">)]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">]</span> <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values1</span><span class="p">,</span> <span class="n">values2</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">get_sample_allocation_matrix_mlmc</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the sample allocation matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nmodel : integer</span>
<span class="sd">        The number of models :math:`M`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mat : np.ndarray (nmodels, 2*nmodels)</span>
<span class="sd">        For columns :math:`2j, j=0,\ldots,M-1` the ith row contains a</span>
<span class="sd">        flag specifiying if :math:`z_i^\star\subseteq z_j^\star`</span>
<span class="sd">        For columns :math:`2j+1, j=0,\ldots,M-1` the ith row contains a</span>
<span class="sd">        flag specifiying if :math:`z_i\subseteq z_j`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmodels</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">mat</span>


<span class="k">def</span> <span class="nf">get_npartition_samples_mlmc</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the size of the partitions combined to form</span>
<span class="sd">        :math:`z_i, i=0\ldots, M-1`.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nsamples_per_model : np.ndarray (nmodels)</span>
<span class="sd">         The number of total samples allocated to each model. I.e.</span>
<span class="sd">         :math:`|z_i\cup\z^\star_i|, i=0,\ldots,M-1`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    npartition_samples : np.ndarray (nmodels)</span>
<span class="sd">        The size of the partitions that make up the subsets</span>
<span class="sd">        :math:`z_i, i=0\ldots, M-1`. These are represented by different</span>
<span class="sd">        color blocks in the ACV papers figures of sample allocation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">npartition_samples</span> <span class="o">=</span> <span class="n">pkg_empty</span><span class="p">(</span>
        <span class="p">(</span><span class="n">nmodels</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">npartition_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">npartition_samples</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">nsamples_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">npartition_samples</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">npartition_samples</span>


<span class="k">def</span> <span class="nf">get_sample_allocation_matrix_mfmc</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmodels</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">))</span>
    <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">mat</span>


<span class="k">def</span> <span class="nf">get_npartition_samples_mfmc</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">):</span>
    <span class="n">npartition_samples</span> <span class="o">=</span> <span class="n">pkg_hstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pkg_diff</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">npartition_samples</span>


<span class="k">def</span> <span class="nf">get_sample_allocation_matrix_acvmf</span><span class="p">(</span><span class="n">recursion_index</span><span class="p">):</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">recursion_index</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmodels</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">recursion_index</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">II</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mat</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mat</span><span class="p">[:</span><span class="n">II</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">mat</span>


<span class="k">def</span> <span class="nf">get_npartition_samples_acvmf</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">):</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">)</span>
    <span class="n">II</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">),</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sort_array</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="n">II</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sort_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nmodels</span><span class="p">:</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="n">sort_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">pkg_ones</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="n">sort_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">type</span><span class="p">(</span><span class="n">sort_array</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="n">sort_array</span> <span class="o">=</span> <span class="n">pkg_hstack</span><span class="p">((</span><span class="n">sort_array</span><span class="p">,</span> <span class="n">pad</span><span class="p">))</span>
    <span class="n">npartition_samples</span> <span class="o">=</span> <span class="n">pkg_hstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pkg_diff</span><span class="p">(</span><span class="n">sort_array</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">npartition_samples</span>


<span class="k">def</span> <span class="nf">get_sample_allocation_matrix_acvis</span><span class="p">(</span><span class="n">recursion_index</span><span class="p">):</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">recursion_index</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmodels</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">recursion_index</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">],</span> <span class="n">mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">mat</span>


<span class="k">def</span> <span class="nf">get_npartition_samples_acvis</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the size of the subsets :math:`z_i\setminus z_i^\star, i=0\ldots, M-1`.</span>

<span class="sd">    # Warning this will likely not work when recursion index is not [0, 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">npartition_samples</span> <span class="o">=</span> <span class="n">pkg_hstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">npartition_samples</span>


<span class="k">def</span> <span class="nf">get_nsamples_intersect</span><span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">,</span> <span class="n">npartition_samples</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nsamples_intersect : np.ndarray (2*nmodels, 2*nmodels)</span>
<span class="sd">        The i,j entry contains contains</span>
<span class="sd">        :math:`|z^\star_i\cap\z^\star_j|` when i%2==0 and j%2==0</span>
<span class="sd">        :math:`|z_i\cap\z^\star_j|` when i%2==1 and j%2==0</span>
<span class="sd">        :math:`|z_i^\star\cap\z_j|` when i%2==0 and j%2==1</span>
<span class="sd">        :math:`|z_i\cap\z_j|` when i%2==1 and j%2==1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">reorder_allocation_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nsubset_samples</span> <span class="o">=</span> <span class="n">npartition_samples</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">reorder_allocation_mat</span>
    <span class="n">nsamples_intersect</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">nsamples_intersect</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">nsubset_samples</span><span class="p">[</span><span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nsamples_intersect</span>


<span class="k">def</span> <span class="nf">get_nsamples_interesect_from_z_subsets_acvgmf</span><span class="p">(</span>
        <span class="n">nsamples_z_subsets</span><span class="p">,</span> <span class="n">recursion_index</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nsamples_z_subsets : np.ndarray (nmodels)</span>
<span class="sd">        The number of samples in the subset :math:`z_i`</span>
<span class="sd">       (not :math::`z_i^\star`) for each model</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">recursion_index</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">nsamples_intersect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">))</span>
    <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nsamples_intersect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
            <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="n">recursion_index</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="n">recursion_index</span><span class="p">[</span><span class="n">jj</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="n">recursion_index</span><span class="p">[</span><span class="n">jj</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="n">recursion_index</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
            <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">nsamples_z_subsets</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">nsamples_intersect</span>


<span class="k">def</span> <span class="nf">get_nsamples_subset</span><span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">,</span> <span class="n">npartition_samples</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of samples allocated to the sample subsets</span>
<span class="sd">    :math:`|z^\star_i` and :math:`|z_i|`</span>

<span class="sd">    npartition_samples : np.ndarray (nmodels)</span>
<span class="sd">        The size of the partitions that make up the subsets</span>
<span class="sd">        :math:`z_i, i=0\ldots, M-1`. These are represented by different</span>
<span class="sd">        color blocks in the ACV papers figures of sample allocation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">reorder_allocation_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nsamples_subset</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">((</span>
        <span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">nsamples_subset</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">npartition_samples</span><span class="p">[</span><span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">nsamples_subset</span>


<span class="k">def</span> <span class="nf">reorder_allocation_matrix_acvgmf</span><span class="p">(</span><span class="n">allocation_mat</span><span class="p">,</span> <span class="n">nsamples_per_model</span><span class="p">,</span>
                                     <span class="n">recursion_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Allocation matrix is the reference sample allocation</span>

<span class="sd">    Must make sure that allocation matrix used for sample allocation and</span>
<span class="sd">    computing estimated variances has the largest sample sizes containing</span>
<span class="sd">    the largest subset</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># WARNING Will only work for acvmf and not acvgis</span>
    <span class="n">II</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">pkg_copy</span><span class="p">(</span><span class="n">allocation_mat</span><span class="p">)</span>
    <span class="n">tmp</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">allocation_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">II</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tmp</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">recursion_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tmp</span>


<span class="k">def</span> <span class="nf">get_acv_discrepancy_covariances_multipliers</span><span class="p">(</span>
        <span class="n">allocation_mat</span><span class="p">,</span> <span class="n">nsamples_per_model</span><span class="p">,</span> <span class="n">get_npartition_samples</span><span class="p">,</span>
        <span class="n">recursion_index</span><span class="p">):</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">allocation_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">reorder_allocation_mat</span> <span class="o">=</span> <span class="n">reorder_allocation_matrix_acvgmf</span><span class="p">(</span>
        <span class="n">allocation_mat</span><span class="p">,</span> <span class="n">nsamples_per_model</span><span class="p">,</span> <span class="n">recursion_index</span><span class="p">)</span>
    <span class="n">npartition_samples</span> <span class="o">=</span> <span class="n">get_npartition_samples</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span>
        <span class="n">npartition_samples</span><span class="p">)</span>
    <span class="n">nsamples_intersect</span> <span class="o">=</span> <span class="n">get_nsamples_intersect</span><span class="p">(</span>
        <span class="n">reorder_allocation_mat</span><span class="p">,</span> <span class="n">npartition_samples</span><span class="p">)</span>
    <span class="n">nsamples_subset</span> <span class="o">=</span> <span class="n">get_nsamples_subset</span><span class="p">(</span>
        <span class="n">reorder_allocation_mat</span><span class="p">,</span> <span class="n">npartition_samples</span><span class="p">)</span>
    <span class="n">Gmat</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">gvec</span> <span class="o">=</span> <span class="n">pkg_zeros</span><span class="p">((</span><span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">gvec</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span>
                <span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span>
            <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span>
                <span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
            <span class="n">Gmat</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">]</span><span class="o">/</span><span class="p">(</span>
                    <span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">])</span> <span class="o">-</span>
                <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span>
                    <span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span>
                <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">]</span><span class="o">/</span><span class="p">(</span>
                    <span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">])</span> <span class="o">+</span>
                <span class="n">nsamples_intersect</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span>
                    <span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nsamples_subset</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">Gmat</span><span class="p">,</span> <span class="n">gvec</span>


<span class="k">def</span> <span class="nf">get_acv_discrepancy_covariances</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">Gmat</span><span class="p">,</span> <span class="n">gvec</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Gmat</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">gvec</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>


<span class="k">def</span> <span class="nf">get_generalized_approximate_control_variate_weights</span><span class="p">(</span>
        <span class="n">allocation_mat</span><span class="p">,</span> <span class="n">nsamples_per_model</span><span class="p">,</span> <span class="n">get_npartition_samples</span><span class="p">,</span>
        <span class="n">cov</span><span class="p">,</span> <span class="n">recursion_index</span><span class="p">):</span>
    <span class="n">Gmat</span><span class="p">,</span> <span class="n">gvec</span> <span class="o">=</span> <span class="n">get_acv_discrepancy_covariances_multipliers</span><span class="p">(</span>
        <span class="n">allocation_mat</span><span class="p">,</span> <span class="n">nsamples_per_model</span><span class="p">,</span> <span class="n">get_npartition_samples</span><span class="p">,</span>
        <span class="n">recursion_index</span><span class="p">)</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Fmat</span><span class="p">,</span> <span class="n">fvec</span> <span class="o">=</span> <span class="n">Gmat</span><span class="o">*</span><span class="n">nhf_samples</span><span class="p">,</span> <span class="n">gvec</span><span class="o">*</span><span class="n">nhf_samples</span>
    <span class="n">CF</span><span class="p">,</span> <span class="n">cf</span> <span class="o">=</span> <span class="n">get_acv_discrepancy_covariances</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">Fmat</span><span class="p">,</span> <span class="n">fvec</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">get_approximate_control_variate_weights</span><span class="p">(</span><span class="n">CF</span><span class="p">,</span> <span class="n">cf</span><span class="p">)</span>

    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;linalgerror: acv weights failed&quot;</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">pkg_ones</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">cf</span><span class="p">),</span> <span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">*</span><span class="mf">1e16</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;runtime: acv weights failed&quot;</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">pkg_ones</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">cf</span><span class="p">),</span> <span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">*</span><span class="mf">1e16</span>
    <span class="k">return</span> <span class="n">weights</span><span class="p">,</span> <span class="n">cf</span>


<span class="k">def</span> <span class="nf">acv_estimator_variance</span><span class="p">(</span><span class="n">allocation_mat</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span>
                           <span class="n">get_npartition_samples</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">recursion_index</span><span class="p">,</span>
                           <span class="n">nsample_ratios</span><span class="p">):</span>
    <span class="n">nsamples_per_model</span> <span class="o">=</span> <span class="n">get_nsamples_per_model</span><span class="p">(</span>
        <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">weights</span><span class="p">,</span> <span class="n">cf</span> <span class="o">=</span> <span class="n">get_generalized_approximate_control_variate_weights</span><span class="p">(</span>
            <span class="n">allocation_mat</span><span class="p">,</span> <span class="n">nsamples_per_model</span><span class="p">,</span>
            <span class="n">get_npartition_samples</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">recursion_index</span><span class="p">)</span>
    <span class="n">rsquared</span> <span class="o">=</span> <span class="o">-</span><span class="n">cf</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">/</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="c1"># assert rsquared &lt;= 1 or np.all(weights == 1e16), (rsquared, weights)</span>
    <span class="n">variance_reduction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rsquared</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">variance_reduction</span><span class="o">*</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">variance</span>


<span class="k">def</span> <span class="nf">generate_samples_and_values_mfmc</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">,</span> <span class="n">functions</span><span class="p">,</span>
                                     <span class="n">generate_samples</span><span class="p">,</span> <span class="n">acv_modification</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nsamples_per_model : np.ndarray (nsamples)</span>
<span class="sd">            The number of samples allocated to each model</span>

<span class="sd">    functions : list of callables</span>
<span class="sd">        The functions used to evaluate each model</span>

<span class="sd">    generate_samples : callable</span>
<span class="sd">        Function used to generate realizations of the random variables</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples : list</span>
<span class="sd">        List containing the samples :math:`\mathcal{Z}_{i,1}` and</span>
<span class="sd">        :math:`\mathcal{Z}_{i,2}` for each model :math:`i=0,\ldots,M-1`.</span>
<span class="sd">        The list is [[:math:`\mathcal{Z}_{0,1}`,:math:`\mathcal{Z}_{0,2}`],...,[:math:`\mathcal{Z}_{M-1,1}`,:math:`\mathcal{Z}_{M-1,2}`]],</span>
<span class="sd">        where :math:`M` is the number of models</span>

<span class="sd">    values : list</span>
<span class="sd">        Model values at the points in samples</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># nsample_ratios = np.asarray(nsample_ratios)</span>
    <span class="c1"># nlf_samples = validate_nsample_ratios(nhf_samples, nsample_ratios)</span>
    <span class="c1"># nmodels = nsample_ratios.shape[0]+1</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># max_nsamples = nlf_samples.max()</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_nsamples</span> <span class="o">=</span> <span class="n">nsamples_per_model</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">generate_samples</span><span class="p">(</span><span class="n">max_nsamples</span><span class="p">)</span>
    <span class="n">samples2</span> <span class="o">=</span> <span class="p">[</span><span class="n">samples</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nhf_samples</span><span class="p">]]</span>
    <span class="n">samples1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">nprev_samples</span> <span class="o">=</span> <span class="n">nhf_samples</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">samples1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nprev_samples</span><span class="p">])</span>
        <span class="c1"># samples2.append(samples[:, :nlf_samples[ii-1]])</span>
        <span class="n">samples2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nsamples_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">acv_modification</span><span class="p">:</span>
            <span class="n">nprev_samples</span> <span class="o">=</span> <span class="n">nhf_samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nprev_samples</span> <span class="o">=</span> <span class="n">samples2</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">values2</span> <span class="o">=</span> <span class="p">[</span><span class="n">functions</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">samples2</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">values1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="n">values_ii</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">ii</span><span class="p">](</span><span class="n">samples2</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        <span class="n">values1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values_ii</span><span class="p">[:</span><span class="n">samples1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">values2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values_ii</span><span class="p">)</span>

    <span class="n">samples</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]</span> <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">samples1</span><span class="p">,</span> <span class="n">samples2</span><span class="p">)]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">]</span> <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values1</span><span class="p">,</span> <span class="n">values2</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">acv_sample_allocation_objective_all</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">use_torch</span><span class="p">:</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">jac</span><span class="p">:</span>
            <span class="n">ratios</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">_get_variance_for_optimizer</span><span class="p">(</span><span class="n">target_cost</span><span class="p">,</span> <span class="n">ratios</span><span class="p">)</span>
    <span class="n">log_10_var</span> <span class="o">=</span> <span class="n">pkg</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">jac</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">use_torch</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">log_10_var</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">log_10_var</span>
    <span class="n">log_10_var</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">ratios</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ratios</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>
    <span class="c1"># print(x, log_10_var.item(), grad)</span>
    <span class="k">return</span> <span class="n">log_10_var</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">grad</span>


<span class="k">def</span> <span class="nf">mlmc_sample_allocation_objective_all_lagrange</span><span class="p">(</span>
        <span class="n">estimator</span><span class="p">,</span> <span class="n">target_variance</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">xrats</span><span class="p">):</span>
    <span class="n">nhf_samples</span><span class="p">,</span> <span class="n">ratios</span><span class="p">,</span> <span class="n">lagrange_mult</span> <span class="o">=</span> <span class="n">xrats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xrats</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xrats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">total_cost</span> <span class="o">=</span> <span class="n">nhf_samples</span><span class="o">*</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="n">ratios</span><span class="o">*</span><span class="n">nhf_samples</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">var_red</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">_variance_reduction</span><span class="p">(</span><span class="n">estimator</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">ratios</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">var_red</span><span class="o">*</span><span class="n">estimator</span><span class="o">.</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nhf_samples</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">total_cost</span><span class="o">+</span><span class="n">lagrange_mult</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">variance</span><span class="o">-</span><span class="n">target_variance</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_torch</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mlmc_sample_allocation_jacobian_all_lagrange_torch</span><span class="p">(</span>
        <span class="n">estimator</span><span class="p">,</span> <span class="n">target_variance</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">xrats</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># xrats.requires_grad = True</span>
    <span class="n">nhf_samples</span><span class="p">,</span> <span class="n">ratios</span><span class="p">,</span> <span class="n">lagrange_mult</span> <span class="o">=</span> <span class="n">xrats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xrats</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xrats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">total_cost</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nhf_samples</span><span class="o">+</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ratios</span><span class="o">*</span><span class="n">nhf_samples</span><span class="p">)</span>
    <span class="n">var_red</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">_variance_reduction</span><span class="p">(</span>
        <span class="n">_ndarray_as_pkg_format</span><span class="p">(</span><span class="n">estimator</span><span class="o">.</span><span class="n">cov</span><span class="p">),</span> <span class="n">ratios</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">var_red</span><span class="o">*</span><span class="n">estimator</span><span class="o">.</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nhf_samples</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">total_cost</span><span class="o">+</span><span class="n">lagrange_mult</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">variance</span><span class="o">-</span><span class="n">target_variance</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">xrats</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">xrats</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">grad</span>


<span class="k">def</span> <span class="nf">get_acv_initial_guess</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">initial_guess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">constraint_val</span> <span class="o">=</span> <span class="n">acv_sample_allocation_nhf_samples_constraint</span><span class="p">(</span>
            <span class="n">initial_guess</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">constraint_val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not a feasiable initial guess&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">initial_guess</span>

    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nmodels</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># nmodels = cov.shape[0]</span>
    <span class="c1"># nratios = np.empty(nmodels-1)</span>
    <span class="c1"># for ii in range(1, nmodels):</span>
    <span class="c1">#     idx = np.array([0, ii])</span>
    <span class="c1">#     nratio = allocate_samples_mfmc(</span>
    <span class="c1">#         cov[np.ix_(idx, idx)], costs[idx], target_cost)[0]</span>
    <span class="c1">#     nratios[ii-1] = nratio</span>

    <span class="c1"># scale ratios so that nhf_samples is one</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># use (1-1e-8) to avoid numerical precision problems so that</span>
    <span class="c1"># acv_sample_allocation_nhf_samples_constraint is always positive</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_cost</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mf">1e-8</span><span class="p">)</span> <span class="o">-</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nhf_samples</span><span class="p">)</span><span class="o">/</span><span class="n">nratios</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nratios</span><span class="p">)</span><span class="o">*</span><span class="n">delta</span>

    <span class="n">constraint_val</span> <span class="o">=</span> <span class="n">acv_sample_allocation_nhf_samples_constraint</span><span class="p">(</span>
        <span class="n">initial_guess</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">constraint_val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not a feasiable initial guess&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">initial_guess</span>


<span class="k">def</span> <span class="nf">solve_allocate_samples_acv_slsqp_optimization</span><span class="p">(</span>
        <span class="n">estimator</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">optim_options</span><span class="p">,</span> <span class="n">cons</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">optim_options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">optim_options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">:</span> <span class="mf">1e-10</span><span class="p">,</span>
                         <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">10000</span><span class="p">,</span> <span class="s1">&#39;iprint&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="c1"># set iprint=2 to printing iteration info</span>

    <span class="k">if</span> <span class="n">target_cost</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Target cost does not allow at least one sample from each model&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
    <span class="n">nunknowns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">)</span>
    <span class="c1"># bounds = [(1.0, 1e10)]*nunknowns</span>
    <span class="c1"># bounds = [(1.0, np.ceil(target_cost/cost)) for cost in costs[1:]]</span>
    <span class="n">max_nhf</span> <span class="o">=</span> <span class="n">target_cost</span><span class="o">/</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">max_nhf</span><span class="p">),</span>
               <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">target_cost</span><span class="o">/</span><span class="n">cost</span><span class="p">))</span> <span class="k">for</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
    <span class="k">assert</span> <span class="n">nunknowns</span> <span class="o">==</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span>

    <span class="c1"># constraint</span>
    <span class="c1"># nhf*r-nhf &gt;= 1</span>
    <span class="c1"># nhf*(r-1) &gt;= 1</span>
    <span class="c1"># r-1 &gt;= 1/nhf</span>
    <span class="c1"># r &gt;= 1+1/nhf</span>
    <span class="c1"># smallest lower bound whenn nhf = max_nhf</span>

    <span class="n">jac</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">use_torch</span><span class="p">:</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;SLSQP&quot;</span>
    <span class="c1"># method = &quot;trust-constr&quot;</span>
    <span class="c1"># print(optim_options)</span>
    <span class="c1"># del optim_options[&#39;ftol&#39;]</span>
    <span class="c1"># del optim_options[&#39;iprint&#39;]</span>
    <span class="c1"># optim_options[&quot;maxiter&quot;] = 10000</span>
    <span class="c1"># optim_options[&quot;gtol&quot;] = 1e-6</span>
    <span class="n">opt</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
        <span class="n">partial</span><span class="p">(</span><span class="n">estimator</span><span class="o">.</span><span class="n">objective</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">),</span>
        <span class="n">initial_guess</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">optim_options</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt</span>


<span class="k">def</span> <span class="nf">allocate_samples_acv</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span>
                         <span class="n">cons</span><span class="o">=</span><span class="p">[],</span>
                         <span class="n">initial_guess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">optim_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the samples to be allocated to each model</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov : np.ndarray (nmodels,nmodels)</span>
<span class="sd">        The covariance C between each of the models. The highest</span>
<span class="sd">        fidelity model is the first model, i.e its variance is cov[0,0]</span>

<span class="sd">    costs : np.ndarray (nmodels)</span>
<span class="sd">        The relative costs of evaluating each model</span>

<span class="sd">    target_cost : float</span>
<span class="sd">        The total cost budget</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of samples of the</span>
<span class="sd">        lower fidelity models, e.g. N_i=r_i*nhf_samples,i=1,...,nmodels-1</span>

<span class="sd">    log10_variance : float</span>
<span class="sd">        The base 10 logarithm of the variance of the estimator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">get_acv_initial_guess</span><span class="p">(</span>
        <span class="n">initial_guess</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">optim_method</span> <span class="o">==</span> <span class="s2">&quot;SLSQP&quot;</span>
    <span class="n">opt</span> <span class="o">=</span> <span class="n">solve_allocate_samples_acv_slsqp_optimization</span><span class="p">(</span>
        <span class="n">estimator</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">target_cost</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">optim_options</span><span class="p">,</span> <span class="n">cons</span><span class="p">)</span>
    <span class="n">nsample_ratios</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">x</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">opt</span><span class="o">.</span><span class="n">success</span><span class="p">:</span><span class="c1"># or opt.nit == 1: nit will be 1 if using only two models</span>
        <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">cons</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">],</span> <span class="n">con</span><span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">](</span><span class="n">opt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">con</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]))</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;SLSQP optimizer failed&#39;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opt</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># var = 1e99</span>
        <span class="c1"># log10_var = 99</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">get_variance</span><span class="p">(</span><span class="n">target_cost</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">)</span>
        <span class="n">log10_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="c1"># print(&#39;Optimized Variance&#39;, 10**opt.fun, 10**log10_var)</span>
    <span class="c1"># assert np.allclose(log10_var, opt.fun)</span>
    <span class="k">return</span> <span class="n">nsample_ratios</span><span class="p">,</span> <span class="n">log10_var</span>


<span class="k">def</span> <span class="nf">get_rsquared_acv_KL_best</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">):</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">opt_rsquared</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># KL = None</span>
    <span class="k">for</span> <span class="n">K</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">get_discrepancy_covariances</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">get_discrepancy_covariances_KL</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">)</span>
            <span class="n">get_rsquared</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">get_rsquared_acv</span><span class="p">,</span>
                <span class="n">get_discrepancy_covariances</span><span class="o">=</span><span class="n">get_discrepancy_covariances</span><span class="p">)</span>
            <span class="n">rsquared</span> <span class="o">=</span> <span class="n">get_rsquared</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">)</span>
            <span class="c1"># print(K,L,rsquared)</span>
            <span class="k">if</span> <span class="n">rsquared</span> <span class="o">&gt;</span> <span class="n">opt_rsquared</span><span class="p">:</span>
                <span class="n">opt_rsquared</span> <span class="o">=</span> <span class="n">rsquared</span>
                <span class="c1"># KL = (K, L)</span>
    <span class="k">return</span> <span class="n">opt_rsquared</span>


<div class="viewcode-block" id="estimate_model_ensemble_covariance"><a class="viewcode-back" href="../../../api/pyapprox.multifidelity.estimate_model_ensemble_covariance.html#pyapprox.multifidelity.estimate_model_ensemble_covariance">[docs]</a><span class="k">def</span> <span class="nf">estimate_model_ensemble_covariance</span><span class="p">(</span><span class="n">npilot_samples</span><span class="p">,</span> <span class="n">generate_samples</span><span class="p">,</span>
                                       <span class="n">model_ensemble</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the covariance of a model ensemble from a set of pilot samples</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    npilot_samples : integer</span>
<span class="sd">        The number of samples used to estimate the covariance</span>

<span class="sd">    generate_samples : callable</span>
<span class="sd">        Function used to generate realizations of the random variable with</span>
<span class="sd">        call signature samples = generate_samples(npilot_samples)</span>

<span class="sd">    model_ensemble : callable or np.ndarray  (nvars, nsamples)</span>
<span class="sd">        Function that takes a set of samples and models ids and evaluates</span>
<span class="sd">        a set of models. See ModelEnsemble.</span>
<span class="sd">        call signature values = model_emsemble(samples)</span>

<span class="sd">        relizations of the random variable</span>

<span class="sd">    nmodels : integer</span>
<span class="sd">        The number of models in the ensemble</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cov : np.ndarray (nqoi,nqoi)</span>
<span class="sd">        The covariance between the model qoi</span>

<span class="sd">    pilot_random_samples : np.ndarray (nvars,npilot_samples)</span>
<span class="sd">        The random samples used to compute the covariance. These samples</span>
<span class="sd">        DO NOT have a model id</span>

<span class="sd">    pilot_values : np.ndaray (npilot_samples,nmodels)</span>
<span class="sd">        The values of each model at the pilot samples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># generate pilot samples</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">generate_samples</span><span class="p">):</span>
        <span class="n">pilot_random_samples</span> <span class="o">=</span> <span class="n">generate_samples</span><span class="p">(</span><span class="n">npilot_samples</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pilot_random_samples</span> <span class="o">=</span> <span class="n">generate_samples</span><span class="p">[:,</span> <span class="p">:</span><span class="n">npilot_samples</span><span class="p">]</span>
    <span class="n">config_vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nmodels</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="c1"># append model ids to pilot smaples</span>
    <span class="n">pilot_samples</span> <span class="o">=</span> <span class="n">get_all_sample_combinations</span><span class="p">(</span>
        <span class="n">pilot_random_samples</span><span class="p">,</span> <span class="n">config_vars</span><span class="p">)</span>
    <span class="c1"># evaluate models at pilot samples</span>
    <span class="n">pilot_values</span> <span class="o">=</span> <span class="n">model_ensemble</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">)</span>
    <span class="n">pilot_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">pilot_values</span><span class="p">,</span> <span class="p">(</span><span class="n">npilot_samples</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">))</span>
    <span class="c1"># compute covariance</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">pilot_values</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cov</span><span class="p">,</span> <span class="n">pilot_random_samples</span><span class="p">,</span> <span class="n">pilot_values</span></div>


<span class="k">def</span> <span class="nf">compute_covariance_from_control_variate_samples</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the covariance between information sources from a set</span>
<span class="sd">    of evaluations of each information source.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : list (nmodels)</span>
<span class="sd">        The evaluations of each information source seperated in form</span>
<span class="sd">        necessary for control variate estimators.</span>
<span class="sd">        Each entry of the list contains</span>

<span class="sd">        values0 : np.ndarray (num_samples_i0,num_qoi)</span>
<span class="sd">           Evaluations  of each model</span>
<span class="sd">           used to compute the estimator :math:`Q_{i,N}` of</span>

<span class="sd">        values1: np.ndarray (num_samples_i1,num_qoi)</span>
<span class="sd">            Evaluations used compute the approximate</span>
<span class="sd">             mean :math:`\mu_{i,r_iN}` of the low fidelity models.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cov : np.ndarray (nmodels)</span>
<span class="sd">        The covariance between the information sources</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shared_samples_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">])</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">shared_samples_values</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># print(cov,&#39;\n&#39;,cov_matrix)</span>
    <span class="k">return</span> <span class="n">cov</span>


<div class="viewcode-block" id="plot_correlation_matrix"><a class="viewcode-back" href="../../../api/pyapprox.multifidelity.plot_correlation_matrix.html#pyapprox.multifidelity.plot_correlation_matrix">[docs]</a><span class="k">def</span> <span class="nf">plot_correlation_matrix</span><span class="p">(</span><span class="n">corr_matrix</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot a correlation matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    corr_matrix : np.ndarray (nvars, nvars)</span>
<span class="sd">         The correlation between a set of random variabels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pyapprox.util.configure_plots</span> <span class="kn">import</span> <span class="n">plt</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">corr_matrix</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;jet&quot;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">corr_matrix</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{:1.3f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nmodels</span> <span class="o">=</span> <span class="n">corr_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">model_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s2">&quot;$f_{</span><span class="si">%d</span><span class="s2">}$&quot;</span> <span class="o">%</span> <span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">)]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model_names</span><span class="p">)))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model_names</span><span class="p">)))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">model_names</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">model_names</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span></div>


<span class="k">def</span> <span class="nf">get_nhf_samples</span><span class="p">(</span><span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of high-fidelity samples from a target cost and</span>
<span class="sd">    set of lower-fidelity sample ratios.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_cost : float</span>
<span class="sd">        The total cost budget</span>

<span class="sd">    costs : np.ndarray (nmodels)</span>
<span class="sd">        The relative costs of evaluating each model</span>

<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of samples of the</span>
<span class="sd">        lower fidelity models, e.g. N_i = r_i*nhf_samples, i=1,...,nmodels-1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nhf_samples : float</span>
<span class="sd">        The number of high-fidelity samples. This may not be an integer</span>
<span class="sd">        rouning is taken care of elsewhere</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">target_cost</span><span class="o">/</span><span class="p">(</span>
        <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">nsample_ratios</span><span class="o">*</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">nhf_samples</span>


<span class="k">def</span> <span class="nf">get_nsamples_per_model</span><span class="p">(</span><span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">,</span> <span class="n">isinteger</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the number of samples allocated to each model. The samples may not</span>
<span class="sd">    be integers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_cost : float</span>
<span class="sd">        The total cost budget</span>

<span class="sd">    costs : np.ndarray (nmodels)</span>
<span class="sd">        The relative costs of evaluating each model</span>

<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of</span>

<span class="sd">    isinteger : boolean</span>
<span class="sd">        Ensure that nsamples are integers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nsamples_per_model : np.ndarray (nmodels)</span>
<span class="sd">        The number of high-fidelity samples. This may not be an integer</span>
<span class="sd">        rouning is taken care of elsewhere</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nhf_samples</span> <span class="o">=</span> <span class="n">get_nhf_samples</span><span class="p">(</span><span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">)</span>
    <span class="n">nsamples_per_model</span> <span class="o">=</span> <span class="n">pkg_hstack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">nhf_samples</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="o">*</span><span class="n">nhf_samples</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">isinteger</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cast_to_integers</span><span class="p">(</span><span class="n">nsamples_per_model</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nsamples_per_model</span>


<span class="k">def</span> <span class="nf">round_nsample_ratios</span><span class="p">(</span><span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return sample ratios that produce integer sample allocations.</span>
<span class="sd">    The cost of the returned allocation will not usually equal target cost</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_cost : float</span>
<span class="sd">        The total cost budget</span>

<span class="sd">    costs : np.ndarray (nmodels)</span>
<span class="sd">        The relative costs of evaluating each model</span>

<span class="sd">    nsample_ratios : np.ndarray (nmodels-1)</span>
<span class="sd">        The sample ratios r used to specify the number of samples of the</span>
<span class="sd">        lower fidelity models, e.g. N_i = r_i*nhf_samples, i=1,...,nmodels-1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nsample_ratios_floor : float</span>
<span class="sd">         ratios r used to specify INTEGER number of samples of the lower</span>
<span class="sd">         fidelity models. These ratios will also force nhf_samples to</span>
<span class="sd">         be an integer</span>

<span class="sd">    rounded_target_cost : float</span>
<span class="sd">         The cost of the new sample allocation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nsamples_float</span> <span class="o">=</span> <span class="n">get_nsamples_per_model</span><span class="p">(</span>
        <span class="n">target_cost</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">nsample_ratios</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">nsamples_floor</span> <span class="o">=</span> <span class="n">nsamples_float</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># ensure all low-fidelity samples &gt; nhf_samples after rounding</span>
    <span class="k">if</span> <span class="n">nsamples_floor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">nsamples_float</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">-</span><span class="mf">1e-8</span><span class="p">:</span>
        <span class="c1"># print(nsamples_floor[0], nsamples_float[0], nsamples_float[0]-1, costs)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Rounding likely caused nhf samples to be zero&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">nsamples_floor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">nsamples_floor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">nsamples_floor</span><span class="p">,</span> <span class="s2">&quot;nsf1&quot;</span><span class="p">)</span>
    <span class="n">II</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nsamples_floor</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">nsamples_floor</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">nsamples_floor</span><span class="p">[</span><span class="n">II</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">nsamples_floor</span><span class="p">,</span> <span class="s2">&quot;nsf2&quot;</span><span class="p">)</span>
    <span class="n">nsample_ratios_floor</span> <span class="o">=</span> <span class="n">nsamples_floor</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">/</span><span class="n">nsamples_floor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rounded_target_cost</span> <span class="o">=</span> <span class="n">nsamples_floor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">nsample_ratios_floor</span><span class="p">,</span> <span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="c1"># nhf_samples_floor = int(nsamples_float[0])</span>
    <span class="c1"># nlf_samples_floor = (</span>
    <span class="c1">#     nhf_samples_floor*np.asarray(nsample_ratios)).astype(int)</span>
    <span class="c1"># nsample_ratios_floor = nlf_samples_floor/nhf_samples_floor</span>
    <span class="c1"># rounded_target_cost = nhf_samples_floor*(costs[0]+np.dot(</span>
    <span class="c1">#     nsample_ratios_floor, costs[1:]))</span>
    <span class="k">return</span> <span class="n">nsample_ratios_floor</span><span class="p">,</span> <span class="n">rounded_target_cost</span>


<span class="k">def</span> <span class="nf">generate_samples_acv</span><span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">,</span> <span class="n">nsamples_per_model</span><span class="p">,</span>
                         <span class="n">npartition_samples</span><span class="p">,</span> <span class="n">generate_samples</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the samples needded to evaluate the approximate the control</span>
<span class="sd">    variate estimator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    allocation_mat : np.ndarray (nmodels, 2*nmodels)</span>
<span class="sd">        For columns :math:`2j, j=0,\ldots,M-1` the ith row contains a</span>
<span class="sd">        flag specifiying if :math:`z_i^\star\subseteq z_j^\star`</span>
<span class="sd">        For columns :math:`2j+1, j=0,\ldots,M-1` the ith row contains a</span>
<span class="sd">        flag specifiying if :math:`z_i\subseteq z_j`</span>

<span class="sd">    nsamples_per_model : np.ndarray (nsamples)</span>
<span class="sd">            The number of samples allocated to each model</span>

<span class="sd">    npartition_samples : np.ndarray (nmodels)</span>
<span class="sd">        The size of the partitions that make up the subsets</span>
<span class="sd">        :math:`z_i, i=0\ldots, M-1`. These are represented by different</span>
<span class="sd">        color blocks in the ACV papers figures of sample allocation</span>

<span class="sd">    generate_samples : callable</span>
<span class="sd">        Function used to generate realizations of the random variables with</span>
<span class="sd">        signature</span>

<span class="sd">        `generate_samples(nsamples) -&gt; np.ndarray(nvars, nsamples)`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples_per_model : list (nmodels)</span>
<span class="sd">            The ith entry contains the set of samples</span>
<span class="sd">            np.narray(nvars, nsamples_ii) used to evaluate the ith model.</span>

<span class="sd">    partition_indices_per_model : list (nmodels)</span>
<span class="sd">            The ith entry contains the indices np.narray(nsamples_ii)</span>
<span class="sd">            mapping each sample to a sample allocation partition</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">npartition_samples</span> <span class="o">=</span> <span class="n">cast_to_integers</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">npartition_samples</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">reorder_allocation_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="n">npartition_samples</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">generate_samples</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>
    <span class="n">nvars</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ubs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">ss</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">npartition_samples</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">lbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">ubs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">samples_per_model</span><span class="p">,</span> <span class="n">partition_indices_per_model</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">active_partitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
            <span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nsamples_ii</span> <span class="o">=</span> <span class="n">npartition_samples</span><span class="p">[</span><span class="n">active_partitions</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">samples_per_model_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nvars</span><span class="p">,</span> <span class="n">nsamples_ii</span><span class="p">))</span>
        <span class="n">partition_indices_per_model_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nsamples_ii</span><span class="p">))</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">active_partitions</span><span class="p">:</span>
            <span class="n">samples_per_model_ii</span><span class="p">[:,</span> <span class="n">cnt</span><span class="p">:</span><span class="n">cnt</span><span class="o">+</span><span class="n">npartition_samples</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> \
                <span class="n">samples</span><span class="p">[:,</span> <span class="n">lbs</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span><span class="n">ubs</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
            <span class="n">partition_indices_per_model_ii</span><span class="p">[</span>
                <span class="n">cnt</span><span class="p">:</span><span class="n">cnt</span><span class="o">+</span><span class="n">npartition_samples</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="n">npartition_samples</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">samples_per_model</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples_per_model_ii</span><span class="p">)</span>
        <span class="n">partition_indices_per_model</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">partition_indices_per_model_ii</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples_per_model</span><span class="p">,</span> <span class="n">partition_indices_per_model</span>


<span class="k">def</span> <span class="nf">separate_model_values_acv</span><span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">,</span>
                              <span class="n">values_per_model</span><span class="p">,</span> <span class="n">partition_indices_per_model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Separate a list of model evaluations for each model into the separated</span>
<span class="sd">    form necessary to evaluate the approximate the control variate estimator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    allocation_mat : np.ndarray (nmodels, 2*nmodels)</span>
<span class="sd">        For columns :math:`2j, j=0,\ldots,M-1` the ith row contains a</span>
<span class="sd">        flag specifiying if :math:`z_i^\star\subseteq z_j^\star`</span>
<span class="sd">        For columns :math:`2j+1, j=0,\ldots,M-1` the ith row contains a</span>
<span class="sd">        flag specifiying if :math:`z_i\subseteq z_j`</span>

<span class="sd">    values_per_model : list (nmodels)</span>
<span class="sd">            The ith entry contains the set of evaluations</span>
<span class="sd">            np.narray(nsamples_ii, nqoi) of the ith model.</span>

<span class="sd">    partition_indices_per_model : list (nmodels)</span>
<span class="sd">            The ith entry contains the indices np.narray(nsamples_ii)</span>
<span class="sd">            mapping each sample to a sample allocation partition</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    acv_values : list (nmodels)</span>
<span class="sd">        The evaluations of each information source seperated in form</span>
<span class="sd">        necessary for control variate estimators.</span>
<span class="sd">        Each entry of the list contains</span>

<span class="sd">        values0 : np.ndarray (num_samples_i0,num_qoi)</span>
<span class="sd">           Evaluations  of each model</span>
<span class="sd">           used to compute the estimator :math:`Q_{i,N}` of</span>

<span class="sd">        values1: np.ndarray (num_samples_i1,num_qoi)</span>
<span class="sd">            Evaluations used compute the approximate</span>
<span class="sd">            mean :math:`\mu_{i,r_iN}` of the low fidelity models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values_per_model</span><span class="p">)</span>
    <span class="n">acv_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">active_partitions_ii_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">values_ii_1_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">active_partitions_ii_1</span><span class="p">:</span>
            <span class="n">values_ii_1_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">values_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">partition_indices_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ii</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values_ii_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">values_ii_1_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values_ii_1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">active_partitions_ii_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">values_ii_2_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">active_partitions_ii_2</span><span class="p">:</span>
            <span class="n">values_ii_2_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">values_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">partition_indices_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx</span><span class="p">])</span>
        <span class="n">values_ii_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">values_ii_2_list</span><span class="p">)</span>
        <span class="n">acv_values</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">values_ii_1</span><span class="p">,</span> <span class="n">values_ii_2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">acv_values</span>


<span class="k">def</span> <span class="nf">separate_samples_per_model_acv</span><span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">,</span> <span class="n">samples_per_model</span><span class="p">,</span>
                                   <span class="n">subset_indices_per_model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Separate a list of samples for each model into the separated</span>
<span class="sd">    form necessary to evaluate the approximate the control variate estimator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    allocation_mat : np.ndarray (nmodels, 2*nmodels)</span>
<span class="sd">        For columns :math:`2j, j=0,\ldots,M-1` the ith row contains a</span>
<span class="sd">        flag specifiying if :math:`z_i^\star\subseteq z_j^\star`</span>
<span class="sd">        For columns :math:`2j+1, j=0,\ldots,M-1` the ith row contains a</span>
<span class="sd">        flag specifiying if :math:`z_i\subseteq z_j`</span>

<span class="sd">    samples_per_model : list (nmodels)</span>
<span class="sd">            The ith entry contains the set of evaluations</span>
<span class="sd">            np.narray(nvars, nsamples_ii) of the ith model.</span>

<span class="sd">    partition_indices_per_model : list (nmodels)</span>
<span class="sd">            The ith entry contains the indices np.narray(nsamples_ii)</span>
<span class="sd">            mapping each sample to a sample allocation partition</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    acv_samples : list (nmodels)</span>
<span class="sd">        The samples for each information source seperated in form</span>
<span class="sd">        necessary for control variate estimators.</span>
<span class="sd">        Each entry of the list contains</span>

<span class="sd">        samples0 : np.ndarray (nvars, num_samples_i0)</span>
<span class="sd">           Evaluations  of each model</span>
<span class="sd">           used to compute the estimator :math:`Q_{i,N}` of</span>

<span class="sd">        samples1: np.ndarray (nvars, num_samples_i1)</span>
<span class="sd">            Evaluations used compute the approximate</span>
<span class="sd">            mean :math:`\mu_{i,r_iN}` of the low fidelity models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples_per_model</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">acv_samples</span> <span class="o">=</span> <span class="n">separate_model_values_acv</span><span class="p">(</span>
        <span class="n">reorder_allocation_mat</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">subset_indices_per_model</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ii</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">acv_samples</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">acv_samples</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">acv_samples</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">acv_samples</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">acv_samples</span>


<span class="k">def</span> <span class="nf">bootstrap_acv_estimator</span><span class="p">(</span><span class="n">values_per_model</span><span class="p">,</span> <span class="n">partition_indices_per_model</span><span class="p">,</span>
                            <span class="n">npartition_samples</span><span class="p">,</span> <span class="n">reorder_allocation_mat</span><span class="p">,</span>
                            <span class="n">acv_weights</span><span class="p">,</span> <span class="n">nbootstraps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Approximate the variance of the Monte Carlo estimate of the mean using</span>
<span class="sd">    bootstraping</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    acv_weights : np.ndarray (nmodels-1)</span>
<span class="sd">        The control variate weights</span>

<span class="sd">    nbootstraps : integer</span>
<span class="sd">        The number of boostraps used to compute estimator variance</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bootstrap_mean : float</span>
<span class="sd">        The bootstrap estimate of the estimator mean</span>

<span class="sd">    bootstrap_var : float</span>
<span class="sd">        The bootstrap estimate of the estimator variance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values_per_model</span><span class="p">)</span>
    <span class="n">npartitions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">)</span>
    <span class="n">npartition_samples</span> <span class="o">=</span> <span class="n">cast_to_integers</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">)</span>
    <span class="c1"># preallocate memory so do not have to do it repeatedly</span>
    <span class="n">permuted_partition_indices</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npartitions</span><span class="p">)]</span>
    <span class="n">permuted_values_per_model</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values_per_model</span><span class="p">]</span>
    <span class="n">active_partitions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">active_partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
            <span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">estimator_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nbootstraps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbootstraps</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npartitions</span><span class="p">):</span>
            <span class="n">n_jj</span> <span class="o">=</span> <span class="n">npartition_samples</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="n">permuted_partition_indices</span><span class="p">[</span><span class="n">jj</span><span class="p">][:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_jj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_jj</span><span class="p">),</span>
                                 <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">active_partitions</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                <span class="n">II</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">partition_indices_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">permuted_values_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">II</span><span class="p">]</span> <span class="o">=</span> <span class="n">values_per_model</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span>
                    <span class="n">II</span><span class="p">[</span><span class="n">permuted_partition_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]]]</span>
        <span class="n">permuted_acv_values</span> <span class="o">=</span> <span class="n">separate_model_values_acv</span><span class="p">(</span>
            <span class="n">reorder_allocation_mat</span><span class="p">,</span> <span class="n">permuted_values_per_model</span><span class="p">,</span>
            <span class="n">partition_indices_per_model</span><span class="p">)</span>
        <span class="n">estimator_vals</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">compute_approximate_control_variate_mean_estimate</span><span class="p">(</span>
                <span class="n">acv_weights</span><span class="p">,</span> <span class="n">permuted_acv_values</span><span class="p">)</span>
    <span class="n">bootstrap_mean</span> <span class="o">=</span> <span class="n">estimator_vals</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">bootstrap_var</span> <span class="o">=</span> <span class="n">estimator_vals</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">bootstrap_mean</span><span class="p">,</span> <span class="n">bootstrap_var</span>


<span class="k">class</span> <span class="nc">ModelTree</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[]):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">!=</span> <span class="n">ModelTree</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">ModelTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>

    <span class="k">def</span> <span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nnodes</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">==</span> <span class="n">ModelTree</span><span class="p">:</span>
                <span class="n">nnodes</span> <span class="o">+=</span> <span class="n">child</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nnodes</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nnodes</span>

    <span class="k">def</span> <span class="nf">to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">())]</span>
        <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_to_index_recusive</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_index_recusive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">index</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">root</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_to_index_recusive</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">update_list_for_reduce</span><span class="p">(</span><span class="n">mylist</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
    <span class="n">mylist</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">mylist</span>


<span class="k">def</span> <span class="nf">generate_all_trees</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tree_depth</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">tree_depth</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">ModelTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">product</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">prod</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">nexts</span><span class="p">,</span> <span class="n">sub_roots</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="n">update_list_for_reduce</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">children</span><span class="p">),</span> <span class="p">([],</span> <span class="p">[]))</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_roots</span><span class="p">)),</span> <span class="n">repeat</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">nexts</span><span class="p">)):</span>
                <span class="n">sub_children</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                    <span class="n">update_list_for_reduce</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">nexts</span><span class="p">),</span>
                    <span class="p">[[]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">sub_roots</span><span class="p">])</span>
                <span class="k">yield from</span> <span class="p">[</span>
                    <span class="n">ModelTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span>
                            <span class="o">*</span><span class="p">(</span><span class="n">generate_all_trees</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">tree_depth</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sub_roots</span><span class="p">,</span> <span class="n">sub_children</span><span class="p">)))]</span>


<span class="k">def</span> <span class="nf">get_acv_recursion_indices</span><span class="p">(</span><span class="n">nmodels</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">nmodels</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Depth </span><span class="si">{</span><span class="n">depth</span><span class="si">}</span><span class="s2"> exceeds number of lower-fidelity models&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">generate_all_trees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">index</span><span class="o">.</span><span class="n">to_index</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>


<span class="k">def</span> <span class="nf">hierarchy_pos</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">vert_gap</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">vert_loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xcenter</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    From Joel&#39;s answer at https://stackoverflow.com/a/29597209/2966723.</span>
<span class="sd">    Licensed under Creative Commons Attribution-Share Alike</span>

<span class="sd">    If the graph is a tree this will return the positions to plot this in a</span>
<span class="sd">    hierarchical layout.</span>

<span class="sd">    G: the graph (must be a tree)</span>

<span class="sd">    root: the root node of current branch</span>
<span class="sd">    - if the tree is directed and this is not given,</span>
<span class="sd">      the root will be found and used</span>
<span class="sd">    - if the tree is directed and this is given, then</span>
<span class="sd">      the positions will be just for the descendants of this node.</span>
<span class="sd">    - if the tree is undirected and not given,</span>
<span class="sd">      then a random choice will be used.</span>

<span class="sd">    width: horizontal space allocated for this branch - avoids overlap with</span>
<span class="sd">           other branches</span>

<span class="sd">    vert_gap: gap between levels of hierarchy</span>

<span class="sd">    vert_loc: vertical location of root</span>

<span class="sd">    xcenter: horizontal location of root</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;cannot use hierarchy_pos on a graph that is not a tree&#39;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hierarchy_pos</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">vert_gap</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">vert_loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">xcenter</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        see hierarchy_pos docstring for most arguments</span>

<span class="sd">        pos: a dict saying where all nodes go if they have been assigned</span>
<span class="sd">        parent: parent of this branch. - only affects it if non-directed</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="n">root</span><span class="p">:</span> <span class="p">(</span><span class="n">xcenter</span><span class="p">,</span> <span class="n">vert_loc</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xcenter</span><span class="p">,</span> <span class="n">vert_loc</span><span class="p">)</span>
        <span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
            <span class="n">nextx</span> <span class="o">=</span> <span class="n">xcenter</span> <span class="o">-</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">dx</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">nextx</span> <span class="o">+=</span> <span class="n">dx</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">_hierarchy_pos</span><span class="p">(</span>
                    <span class="n">G</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">vert_gap</span><span class="o">=</span><span class="n">vert_gap</span><span class="p">,</span>
                    <span class="n">vert_loc</span><span class="o">=</span><span class="n">vert_loc</span><span class="o">-</span><span class="n">vert_gap</span><span class="p">,</span> <span class="n">xcenter</span><span class="o">=</span><span class="n">nextx</span><span class="p">,</span>
                    <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">return</span> <span class="n">_hierarchy_pos</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">vert_gap</span><span class="p">,</span> <span class="n">vert_loc</span><span class="p">,</span> <span class="n">xcenter</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">plot_model_recursion</span><span class="p">(</span><span class="n">recursion_index</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">recursion_index</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nmodels</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">recursion_index</span><span class="p">):</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">hierarchy_pos</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vert_gap</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="p">[</span><span class="mi">2000</span><span class="p">],</span>
            <span class="n">font_size</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">plot_sample_allocation</span><span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">,</span> <span class="n">npartition_samples</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">pyapprox.util.configure_plots</span> <span class="kn">import</span> <span class="n">plt</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="n">reorder_allocation_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">active_partitions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">active_partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
            <span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mf">0.3</span>
    <span class="n">y_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">rainbow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nmodels</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">npartition_samples</span><span class="p">)):</span>
        <span class="n">used_by</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">reorder_allocation_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">used_by</span><span class="p">[</span><span class="n">reorder_allocation_mat</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="p">:]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">selected_colors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">colors</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="k">if</span> <span class="n">uu</span> <span class="k">else</span> <span class="s1">&#39;white&#39;</span> <span class="k">for</span> <span class="n">uu</span> <span class="ow">in</span> <span class="n">used_by</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">npartition_samples</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">y_offset</span><span class="p">,</span>
               <span class="n">color</span><span class="o">=</span><span class="n">selected_colors</span><span class="p">)</span>
        <span class="n">y_offset</span> <span class="o">+=</span> <span class="n">npartition_samples</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>

    <span class="n">xticklabels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
        <span class="n">xticklabels</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">r</span><span class="s2">&quot;$z_</span><span class="si">%d</span><span class="s2">^\star$&quot;</span> <span class="o">%</span> <span class="n">ii</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$z_</span><span class="si">%d</span><span class="s2">$&quot;</span> <span class="o">%</span> <span class="n">ii</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">xticklabels</span><span class="p">)</span>


<div class="viewcode-block" id="plot_model_costs"><a class="viewcode-back" href="../../../api/pyapprox.multifidelity.plot_model_costs.html#pyapprox.multifidelity.plot_model_costs">[docs]</a><span class="k">def</span> <span class="nf">plot_model_costs</span><span class="p">(</span><span class="n">costs</span><span class="p">,</span> <span class="n">model_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">pyapprox.util.configure_plots</span> <span class="kn">import</span> <span class="n">plt</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">nmodels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">model_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s2">&quot;$f_{</span><span class="si">%d</span><span class="s2">}$&quot;</span> <span class="o">%</span> <span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">)]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nmodels</span><span class="p">),</span> <span class="n">costs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nmodels</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">model_names</span><span class="p">)</span></div>



<span class="c1"># Notes</span>
<span class="c1"># using pkg.double when ever creating a torch tensor is esssential.</span>
<span class="c1"># Otherwise autograd will not work.</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019 National Technology &amp; Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>