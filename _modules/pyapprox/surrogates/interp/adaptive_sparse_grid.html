<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyapprox.surrogates.interp.adaptive_sparse_grid &mdash; PyApprox 1.0.2 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            PyApprox
              <img src="../../../../_static/pyapprox-logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../auto_examples/index.html">Software Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../auto_tutorials/index.html">Theoretical Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Benchmarks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../benchmarks.html">Benchmarks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Reference Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../user_reference_guide.html">User Reference Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">PyApprox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyapprox.surrogates.interp.adaptive_sparse_grid</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyapprox.surrogates.interp.adaptive_sparse_grid</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pyapprox.variables.marginals</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">variable_shapes_equivalent</span><span class="p">,</span> <span class="n">is_bounded_discrete_variable</span><span class="p">,</span>
    <span class="n">get_probability_masses</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.util.utilities</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">lists_of_lists_of_arrays_equal</span><span class="p">,</span>
    <span class="n">lists_of_arrays_equal</span><span class="p">,</span> <span class="n">partial_functions_equal</span><span class="p">,</span> <span class="n">hash_array</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.surrogates.interp.indexing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_forward_neighbor</span><span class="p">,</span> <span class="n">get_backward_neighbor</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.surrogates.orthopoly.quadrature</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">clenshaw_curtis_rule_growth</span><span class="p">,</span> <span class="n">constant_increment_growth_rule</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.surrogates.orthopoly.leja_quadrature</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_univariate_leja_quadrature_rule</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.variables.transforms</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AffineTransform</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.util.visualization</span> <span class="kn">import</span> <span class="n">plot_2d_indices</span><span class="p">,</span> <span class="n">plot_3d_indices</span><span class="p">,</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">MaxNLocator</span>
<span class="kn">from</span> <span class="nn">pyapprox.surrogates.interp.sparse_grid</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_sparse_grid_samples</span><span class="p">,</span> <span class="n">integrate_sparse_grid</span><span class="p">,</span>
    <span class="n">evaluate_sparse_grid</span><span class="p">,</span> <span class="n">get_subspace_samples</span><span class="p">,</span>
    <span class="n">get_hierarchical_sample_indices</span><span class="p">,</span> <span class="n">get_subspace_values</span><span class="p">,</span>
    <span class="n">get_subspace_weights</span><span class="p">,</span>
    <span class="n">get_subspace_polynomial_indices</span><span class="p">,</span>
    <span class="n">get_1d_samples_weights</span><span class="p">,</span> <span class="n">update_1d_samples_weights</span><span class="p">,</span>
    <span class="n">integrate_sparse_grid_from_subspace_moments</span><span class="p">,</span>
    <span class="n">evaluate_sparse_grid_from_subspace_values</span><span class="p">,</span>
    <span class="n">integrate_sparse_grid_subspace</span><span class="p">,</span> <span class="n">evaluate_sparse_grid_subspace</span>
 <span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyapprox.surrogates.interp.tensorprod</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">piecewise_univariate_linear_quad_rule</span><span class="p">,</span>
    <span class="n">piecewise_univariate_quadratic_quad_rule</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">mypriorityqueue</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">list</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span>

    <span class="k">def</span> <span class="nf">__neq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">extract_items_from_priority_queue</span><span class="p">(</span><span class="n">pqueue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the items in a priority queue. The items will only be shallow copies</span>
<span class="sd">    of items in queue</span>

<span class="sd">    Priority queue is thread safe so does not support shallow or deep copy</span>
<span class="sd">    One can copy this queue by pushing and popping by original queue will</span>
<span class="sd">    be destroyed. Return a copy of the original queue that can be used to</span>
<span class="sd">    replace the destroyed queue</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pqueue1</span> <span class="o">=</span> <span class="n">mypriorityqueue</span><span class="p">()</span>
    <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">pqueue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">pqueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">pqueue1</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">items</span><span class="p">,</span> <span class="n">pqueue1</span>


<span class="k">def</span> <span class="nf">update_smolyak_coefficients</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">subspace_indices</span><span class="p">,</span> <span class="n">smolyak_coeffs</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">new_index</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">subspace_indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>

    <span class="n">new_smolyak_coeffs</span> <span class="o">=</span> <span class="n">smolyak_coeffs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pyapprox.cython.adaptive_sparse_grid</span> <span class="kn">import</span> \
            <span class="n">update_smolyak_coefficients_pyx</span>
        <span class="k">return</span> <span class="n">update_smolyak_coefficients_pyx</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">subspace_indices</span><span class="p">,</span>
                                               <span class="n">new_smolyak_coeffs</span><span class="p">)</span>
        <span class="c1"># from pyapprox.weave.adaptive_sparse_grid import \</span>
        <span class="c1">#     c_update_smolyak_coefficients failed</span>
        <span class="c1"># # new_index.copy is needed</span>
        <span class="c1"># return c_update_smolyak_coefficients(</span>
        <span class="c1">#    new_index.copy(),subspace_indices,smolyak_coeffs)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;update_smolyak_coefficients extension failed&#39;</span><span class="p">)</span>

    <span class="n">num_vars</span><span class="p">,</span> <span class="n">num_subspace_indices</span> <span class="o">=</span> <span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_subspace_indices</span><span class="p">):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">-</span><span class="n">subspace_indices</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">diff</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_smolyak_coeffs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="n">diff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">new_smolyak_coeffs</span>


<span class="k">def</span> <span class="nf">add_unique_poly_indices</span><span class="p">(</span><span class="n">poly_indices_dict</span><span class="p">,</span> <span class="n">new_poly_indices</span><span class="p">):</span>
    <span class="n">unique_poly_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_unique_poly_indices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly_indices_dict</span><span class="p">)</span>
    <span class="n">array_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">new_poly_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_poly_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">poly_index</span> <span class="o">=</span> <span class="n">new_poly_indices</span><span class="p">[:,</span> <span class="n">jj</span><span class="p">]</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">poly_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">poly_indices_dict</span><span class="p">:</span>
            <span class="n">unique_poly_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_index</span><span class="p">)</span>
            <span class="n">poly_indices_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_unique_poly_indices</span>
            <span class="n">array_indices</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_unique_poly_indices</span>
            <span class="n">num_unique_poly_indices</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array_indices</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly_indices_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">poly_indices_dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">unique_poly_indices</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">array_indices</span>


<span class="k">def</span> <span class="nf">subspace_index_is_admissible</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span> <span class="n">subspace_indices_dict</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">)</span> <span class="ow">in</span> <span class="n">subspace_indices_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">subspace_index</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">num_vars</span> <span class="o">=</span> <span class="n">subspace_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">subspace_index</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">neighbor_index</span> <span class="o">=</span> <span class="n">get_backward_neighbor</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">neighbor_index</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subspace_indices_dict</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">max_level_admissibility_function</span><span class="p">(</span><span class="n">max_level</span><span class="p">,</span> <span class="n">max_level_1d</span><span class="p">,</span>
                                     <span class="n">max_num_sparse_grid_samples</span><span class="p">,</span> <span class="n">error_tol</span><span class="p">,</span>
                                     <span class="n">sparse_grid</span><span class="p">,</span> <span class="n">subspace_index</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">subspace_index</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">max_level</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">error_tol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">error_tol</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span>
                <span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="o">.</span><span class="n">list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Desired accuracy </span><span class="si">%1.2e</span><span class="s1"> obtained. Error: </span><span class="si">%1.2e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">error_tol</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                    <span class="n">sparse_grid</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">No. active subspaces remaining </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">sparse_grid</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">No. samples </span><span class="si">{</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span>  <span class="n">sparse_grid</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Accuracy misleadingly appears reached because &#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;admissibility  criterion is preventing new subspaces &#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;from being added to the active set&#39;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">max_level_1d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subspace_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">subspace_index</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_level_1d</span><span class="p">[</span><span class="n">dd</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Cannot add subspace </span><span class="si">{</span><span class="n">subspace_index</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;Max level of </span><span class="si">{</span><span class="n">max_level_1d</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span><span class="si">}</span><span class="s1"> reached in &#39;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;variable </span><span class="si">{</span><span class="n">dd</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">max_num_sparse_grid_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
        <span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">num_equivalent_function_evaluations</span> <span class="o">&gt;</span>
         <span class="n">max_num_sparse_grid_samples</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Max num evaluations (</span><span class="si">{</span><span class="n">max_num_sparse_grid_samples</span><span class="si">}</span><span class="s1">) reached&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error estimate </span><span class="si">{</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Subspace </span><span class="si">{</span><span class="n">subspace_index</span><span class="si">}</span><span class="s1"> is admissible&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">default_combination_sparse_grid_cost_function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">get_active_subspace_indices</span><span class="p">(</span><span class="n">active_subspace_indices_dict</span><span class="p">,</span>
                                <span class="n">sparse_grid_subspace_indices</span><span class="p">):</span>
    <span class="n">II</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">active_subspace_indices_dict</span><span class="p">:</span>
        <span class="n">II</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">active_subspace_indices_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">sparse_grid_subspace_indices</span><span class="p">[:,</span> <span class="n">II</span><span class="p">],</span> <span class="n">II</span>


<span class="k">def</span> <span class="nf">partition_sparse_grid_samples</span><span class="p">(</span><span class="n">sparse_grid</span><span class="p">):</span>
    <span class="n">num_vars</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">active_subspace_indices</span><span class="p">,</span> <span class="n">active_subspace_idx</span> <span class="o">=</span> <span class="n">get_active_subspace_indices</span><span class="p">(</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">)</span>

    <span class="n">sparse_grid_subspace_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
        <span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">sparse_grid_subspace_idx</span><span class="p">[</span><span class="n">active_subspace_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_vars</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">samples_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">sparse_grid_subspace_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="n">sparse_grid_subspace_idx</span><span class="p">]:</span>
        <span class="n">subspace_poly_indices</span> <span class="o">=</span> \
            <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">subspace_samples</span> <span class="o">=</span> <span class="n">get_sparse_grid_samples</span><span class="p">(</span>
            <span class="n">subspace_poly_indices</span><span class="p">,</span>
            <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span>
            <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subspace_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">subspace_samples</span><span class="p">[:,</span> <span class="n">jj</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samples_dict</span><span class="p">:</span>
                <span class="n">samples_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kk</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">samples</span><span class="p">,</span> <span class="n">subspace_samples</span><span class="p">[:,</span> <span class="n">jj</span><span class="p">:</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">kk</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">num_active_samples</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>\
        <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">active_samples_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_active_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">samples_dict</span><span class="p">:</span>
            <span class="n">active_samples_idx</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span>
            <span class="n">kk</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">kk</span> <span class="o">==</span> <span class="n">num_active_samples</span>

    <span class="n">active_samples</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">active_samples_idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">active_samples</span>


<span class="k">def</span> <span class="nf">plot_adaptive_sparse_grid_2d</span><span class="p">(</span><span class="n">sparse_grid</span><span class="p">,</span> <span class="n">plot_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">samples_marker</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                 <span class="n">active_samples_marker</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
    <span class="n">active_subspace_indices</span><span class="p">,</span> <span class="n">active_subspace_idx</span> <span class="o">=</span> <span class="n">get_active_subspace_indices</span><span class="p">(</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">)</span>

    <span class="c1"># get subspace indices that have been added to the sparse grid,</span>
    <span class="c1"># i.e are not active</span>
    <span class="n">sparse_grid_subspace_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
        <span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">sparse_grid_subspace_idx</span><span class="p">[</span><span class="n">active_subspace_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">plot_grid</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="n">axs</span> <span class="o">=</span> <span class="p">[</span><span class="n">axs</span><span class="p">]</span>

    <span class="n">plot_2d_indices</span><span class="p">(</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">[:,</span> <span class="n">sparse_grid_subspace_idx</span><span class="p">],</span>
        <span class="n">coeffs</span><span class="o">=</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">[</span><span class="n">sparse_grid_subspace_idx</span><span class="p">],</span>
        <span class="n">other_indices</span><span class="o">=</span><span class="n">active_subspace_indices</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\beta_1$&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\alpha_1$&#39;</span><span class="p">)</span>  <span class="c1"># ,rotation=0)</span>

    <span class="k">if</span> <span class="n">plot_grid</span><span class="p">:</span>
        <span class="n">samples</span><span class="p">,</span> <span class="n">active_samples</span> <span class="o">=</span> <span class="n">partition_sparse_grid_samples</span><span class="p">(</span><span class="n">sparse_grid</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">map_from_canonical</span><span class="p">(</span>
            <span class="n">samples</span><span class="p">)</span>
        <span class="n">active_samples</span> <span class="o">=</span> \
            <span class="n">sparse_grid</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">map_from_canonical</span><span class="p">(</span>
                <span class="n">active_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">samples_marker</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">samples_marker</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ms</span><span class="o">=</span><span class="n">samples_marker</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">active_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">active_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                        <span class="n">active_samples_marker</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">active_samples_marker</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">ms</span><span class="o">=</span><span class="n">active_samples_marker</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span>  <span class="n">samples_marker</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">samples_marker</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ms</span><span class="o">=</span><span class="n">samples_marker</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">active_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">active_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span> <span class="n">active_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span>
                            <span class="n">active_samples_marker</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">active_samples_marker</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">ms</span><span class="o">=</span><span class="n">active_samples_marker</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">ya</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span>
            <span class="n">ya</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="c1"># axs[1].set_ylabel(r&#39;$\alpha_1$&#39;,rotation=0)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$z_1$&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">isotropic_refinement_indicator</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span>
                                   <span class="n">num_new_subspace_samples</span><span class="p">,</span>
                                   <span class="n">sparse_grid</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">subspace_index</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>


<span class="k">def</span> <span class="nf">tensor_product_refinement_indicator</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">subspace_index</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>


<span class="k">def</span> <span class="nf">variance_refinement_indicator_old</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">,</span>
                                      <span class="n">sparse_grid</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    when config index is increased but the other indices are 0 the</span>
<span class="sd">    subspace will only have one random sample. Thus the variance</span>
<span class="sd">    contribution will be zero regardless of value of the function value</span>
<span class="sd">    at that sample</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># return subspace_index.sum()</span>
    <span class="n">moments</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">moments</span><span class="p">()</span>
    <span class="n">smolyak_coeffs</span> <span class="o">=</span> <span class="n">update_smolyak_coefficients</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">new_moments</span> <span class="o">=</span> <span class="n">integrate_sparse_grid</span><span class="p">(</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">,</span>
        <span class="n">smolyak_coeffs</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">weights_1d</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mean_only</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">new_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">moments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">new_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">moments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>\
            <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">new_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">moments</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">indicator</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># relative error will not work if value at first grid point is close to</span>
    <span class="c1"># zero</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">)</span>
        <span class="n">indicator</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">qoi_chosen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">indicator</span><span class="p">)</span>
    <span class="c1"># print (qoi_chosen)</span>

    <span class="n">indicator</span> <span class="o">=</span> <span class="n">indicator</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">cost_per_sample</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">eval_cost_function</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_per_sample</span><span class="o">*</span><span class="n">num_new_subspace_samples</span>

    <span class="c1"># compute marginal benefit</span>
    <span class="n">indicator</span> <span class="o">/=</span> <span class="n">cost</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">indicator</span><span class="p">,</span> <span class="n">error</span><span class="p">[</span><span class="n">qoi_chosen</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">variance_refinement_indicator</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">,</span>
                                  <span class="n">sparse_grid</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">mean_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">convex_param</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    when config index is increased but the other indices are 0 the</span>
<span class="sd">    subspace will only have one random sample. Thus the variance</span>
<span class="sd">    contribution will be zero regardless of value of the function value</span>
<span class="sd">    at that sample</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># return subspace_index.sum()</span>
    <span class="n">moments</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">moments</span><span class="p">()</span>
    <span class="n">smolyak_coeffs</span> <span class="o">=</span> <span class="n">update_smolyak_coefficients</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="n">new_moments</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">moments_</span><span class="p">(</span><span class="n">smolyak_coeffs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mean_only</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">new_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">moments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># old version from misc paper</span>
        <span class="c1"># error = np.absolute(new_moments[0]-moments[0])**2 +\</span>
        <span class="c1">#    np.absolute(new_moments[1]-moments[1])</span>
        <span class="c1"># new version from integrated surrogates paper</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">new_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">moments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>\
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">new_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">moments</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">indicator</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="c1"># relative error will not work if value at first grid point is</span>
        <span class="c1"># close to zero</span>
        <span class="c1"># assert np.all(np.absolute(sparse_grid.values[0,:])&gt;1e-6)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">II</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">denom</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">denom</span><span class="p">[</span><span class="n">II</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1">#old version from misc paper</span>
        <span class="c1">#indicator /= denom**2</span>
        <span class="c1"># new version from integrated surrogates paper</span>
        <span class="n">indicator</span> <span class="o">/=</span> <span class="n">denom</span>

    <span class="n">qoi_chosen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">indicator</span><span class="p">)</span>
    <span class="c1">#print (qoi_chosen)</span>

    <span class="n">indicator</span> <span class="o">=</span> <span class="n">indicator</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">cost_per_sample</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">eval_cost_function</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_per_sample</span><span class="o">*</span><span class="n">num_new_subspace_samples</span>

    <span class="c1"># compute marginal benefit</span>
    <span class="n">indicator</span> <span class="o">/=</span> <span class="n">cost</span>

    <span class="c1"># always keep in list</span>
    <span class="n">indicator</span> <span class="o">=</span> <span class="n">convex_param</span><span class="o">*</span><span class="n">indicator</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">convex_param</span><span class="p">)</span><span class="o">/</span><span class="n">subspace_index</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">indicator</span><span class="p">,</span> <span class="n">error</span><span class="p">[</span><span class="n">qoi_chosen</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">cv_refinement_indicator</span><span class="p">(</span><span class="n">validation_samples</span><span class="p">,</span> <span class="n">validation_values</span><span class="p">,</span>
                            <span class="n">subspace_index</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">,</span>
                            <span class="n">sparse_grid</span><span class="p">):</span>
    <span class="n">smolyak_coefficients</span> <span class="o">=</span> <span class="n">update_smolyak_coefficients</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">approx_values</span> <span class="o">=</span> <span class="n">evaluate_sparse_grid</span><span class="p">(</span>
        <span class="n">validation_samples</span><span class="p">[:</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="p">:],</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">,</span>
        <span class="n">smolyak_coefficients</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>

    <span class="n">cost_per_sample</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">eval_cost_function</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_per_sample</span><span class="o">*</span><span class="n">num_new_subspace_samples</span>

    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
        <span class="n">approx_values</span><span class="o">-</span><span class="n">validation_values</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">validation_values</span><span class="p">)</span>
    <span class="n">current_approx_values</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="p">(</span><span class="n">validation_samples</span><span class="p">)</span>
    <span class="n">current_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
        <span class="n">current_approx_values</span><span class="o">-</span><span class="n">validation_values</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">validation_values</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">error</span><span class="o">-</span><span class="n">current_error</span><span class="p">)</span>
    <span class="n">indicator</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">/</span><span class="n">cost</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">indicator</span><span class="p">,</span> <span class="n">error</span>


<span class="k">def</span> <span class="nf">compute_surpluses</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="p">,</span> <span class="n">hierarchical</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">)</span>
    <span class="n">ii</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="n">subspace_samples</span> <span class="o">=</span> <span class="n">get_subspace_samples</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span>
        <span class="n">unique_samples_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">hierarchical</span><span class="p">:</span>
        <span class="n">hier_indices</span> <span class="o">=</span> <span class="n">get_hierarchical_sample_indices</span><span class="p">(</span>
            <span class="n">subspace_index</span><span class="p">,</span>
            <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
            <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>
        <span class="n">subspace_samples</span> <span class="o">=</span> <span class="n">subspace_samples</span><span class="p">[:,</span> <span class="n">hier_indices</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hier_indices</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">current_approx_values</span> <span class="o">=</span> <span class="n">evaluate_sparse_grid</span><span class="p">(</span>
        <span class="n">subspace_samples</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>

    <span class="n">smolyak_coefficients</span> <span class="o">=</span> <span class="n">update_smolyak_coefficients</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="n">new_approx_values</span> <span class="o">=</span> <span class="n">evaluate_sparse_grid</span><span class="p">(</span>
        <span class="n">subspace_samples</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">,</span>
        <span class="n">smolyak_coefficients</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_approx_values</span><span class="o">-</span><span class="n">current_approx_values</span><span class="p">,</span> <span class="n">hier_indices</span>


<span class="k">def</span> <span class="nf">compute_hierarchical_surpluses_direct</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="p">):</span>

    <span class="c1"># only works if not used in multilevel setting</span>
    <span class="k">assert</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">)</span>
    <span class="n">ii</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="n">subspace_samples</span> <span class="o">=</span> <span class="n">get_subspace_samples</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span>
        <span class="n">unique_samples_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">hier_indices</span> <span class="o">=</span> <span class="n">get_hierarchical_sample_indices</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>
    <span class="c1"># hier_indices = np.arange(subspace_samples.shape[1])</span>

    <span class="n">subspace_samples</span> <span class="o">=</span> <span class="n">subspace_samples</span><span class="p">[:,</span> <span class="n">hier_indices</span><span class="p">]</span>

    <span class="n">current_approx_values</span> <span class="o">=</span> <span class="n">evaluate_sparse_grid</span><span class="p">(</span>
        <span class="n">subspace_samples</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>

    <span class="n">subspace_values</span> <span class="o">=</span> <span class="n">get_subspace_values</span><span class="p">(</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
    <span class="n">subspace_values</span> <span class="o">=</span> <span class="n">subspace_values</span><span class="p">[</span><span class="n">hier_indices</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">surpluses</span> <span class="o">=</span> <span class="n">subspace_values</span><span class="o">-</span><span class="n">current_approx_values</span>
    <span class="k">return</span> <span class="n">surpluses</span>


<span class="k">def</span> <span class="nf">surplus_refinement_indicator</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">,</span>
                                 <span class="n">sparse_grid</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hierarchical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">norm_order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="n">surpluses</span><span class="p">,</span> <span class="n">hier_indices</span> <span class="o">=</span> <span class="n">compute_surpluses</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="p">,</span> <span class="n">hierarchical</span><span class="o">=</span><span class="n">hierarchical</span><span class="p">)</span>

    <span class="n">subspace_weights</span> <span class="o">=</span> <span class="n">get_subspace_weights</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">,</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">weights_1d</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hier_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">subspace_weights</span> <span class="o">=</span> <span class="n">subspace_weights</span><span class="p">[</span><span class="n">hier_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">norm_order</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">surpluses</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm_order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">subspace_weights</span><span class="p">,</span> <span class="n">surpluses</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ensure norm_order in [np.inf,1]&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">error</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">surpluses</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># relative error will not work if value at first grid point is close to</span>
    <span class="c1"># zero</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>

    <span class="n">cost_per_sample</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">eval_cost_function</span><span class="p">(</span>
        <span class="n">subspace_index</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_per_sample</span><span class="o">*</span><span class="n">num_new_subspace_samples</span>

    <span class="n">indicator</span> <span class="o">=</span> <span class="n">error</span><span class="o">/</span><span class="n">cost</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">indicator</span><span class="p">,</span> <span class="n">error</span>


<span class="k">def</span> <span class="nf">extract_sparse_grid_quadrature_rule</span><span class="p">(</span><span class="n">asg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns samples in canonical space</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_sparse_grid_points</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">asg</span><span class="o">.</span><span class="n">poly_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># must initialize to zero</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_sparse_grid_points</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">get_sparse_grid_samples</span><span class="p">(</span>
        <span class="n">asg</span><span class="o">.</span><span class="n">poly_indices</span><span class="p">,</span> <span class="n">asg</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">asg</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">asg</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
            <span class="n">subspace_index</span> <span class="o">=</span> <span class="n">asg</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
            <span class="n">subspace_poly_indices</span> <span class="o">=</span> <span class="n">asg</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="n">subspace_weights</span> <span class="o">=</span> <span class="n">get_subspace_weights</span><span class="p">(</span>
                <span class="n">subspace_index</span><span class="p">,</span> <span class="n">asg</span><span class="o">.</span><span class="n">weights_1d</span><span class="p">)</span><span class="o">*</span><span class="n">asg</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subspace_poly_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">poly_index</span> <span class="o">=</span> <span class="n">subspace_poly_indices</span><span class="p">[:,</span> <span class="n">jj</span><span class="p">]</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">poly_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">asg</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">:</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">asg</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">subspace_weights</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;index not found&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">weights</span>


<span class="k">class</span> <span class="nc">SubSpaceRefinementManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span> <span class="o">=</span> <span class="n">num_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_config_vars</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span> <span class="o">=</span> <span class="n">mypriorityqueue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">admissibility_function</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refinement_indicator</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">univariate_growth_rule</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_values_indices_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_equivalent_function_evaluations</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work_qoi_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_var_trans</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique_poly_indices_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enforce_variable_ordering</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_new_subspaces</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># self.prioritize_active_subspaces(</span>
        <span class="c1">#    self.subspace_indices, np.asarray([self.samples.shape[1]]))</span>
        <span class="c1"># self.active_subspace_queue.list[0] = (np.inf,self.error[0],0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="n">priority</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">best_subspace_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">best_active_subspace_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">[</span>
            <span class="p">:,</span> <span class="n">best_subspace_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;refining index </span><span class="si">{</span><span class="n">best_active_subspace_index</span><span class="si">}</span><span class="s1"> &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;with priority </span><span class="si">{</span><span class="n">priority</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;The current number of equivalent function evaluations is &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_equivalent_function_evaluations</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">new_active_subspace_indices</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">refine_and_add_new_subspaces</span><span class="p">(</span><span class="n">best_active_subspace_index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prioritize_active_subspaces</span><span class="p">(</span>
            <span class="n">new_active_subspace_indices</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[</span><span class="n">best_subspace_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">postpone_subspace_refinement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_active_subspace_indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        used to enforce variable ordering</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;postponed_subspace_indices&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">postponed_subspace_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">reactivated_subspace_indices_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">reactivated_subspace_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">activated_keys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># get maximum level of subspace_indices in sparse grid</span>
        <span class="c1"># self.subspace_indices contains active indices as well so exclude</span>
        <span class="c1"># by only considering index front for which non-zero smolyak</span>
        <span class="c1"># coefficients is a proxy</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">)</span>
                     <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_level_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">[:,</span> <span class="n">I</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_level_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_active_subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">new_subspace_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postponed_subspace_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">use</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">new_active_subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">new_subspace_index</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># if conditions correspond respectively to decreasing</span>
                    <span class="c1"># conservatism. On problem I have tested there seems to</span>
                    <span class="c1"># be no difference in final answer</span>
                    <span class="c1"># temp_index = new_subspace_index.copy()</span>
                    <span class="c1"># temp_index[dd-1]=new_subspace_index[dd]</span>
                    <span class="c1"># temp_index[dd]-=1</span>
                    <span class="c1"># temp_key = hash_array(temp_index)</span>
                    <span class="c1"># if temp_key not in self.subspace_indices_dict:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">max_level_1d</span><span class="p">[:</span><span class="n">dd</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">new_subspace_index</span><span class="p">[</span><span class="n">dd</span><span class="p">]):</span>
                        <span class="c1"># if np.any(max_level_1d[:dd]==0):</span>
                        <span class="n">use</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">use</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">admissibility_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_subspace_index</span><span class="p">):</span>
                <span class="n">reactivated_subspace_indices_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">reactivated_subspace_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_subspace_index</span><span class="p">)</span>
                <span class="n">activated_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">activated_keys</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">postponed_subspace_indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">use_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_active_subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">use</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">new_subspace_index</span> <span class="o">=</span> <span class="n">new_active_subspace_indices</span><span class="p">[:,</span> <span class="n">jj</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">new_active_subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">new_subspace_index</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># temp_index = new_subspace_index.copy()</span>
                    <span class="c1"># temp_index[dd-1]=new_subspace_index[dd]</span>
                    <span class="c1"># temp_index[dd]-=1</span>
                    <span class="c1"># temp_key = hash_array(temp_index)</span>
                    <span class="c1"># if temp_key not in self.subspace_indices_dict:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">max_level_1d</span><span class="p">[:</span><span class="n">dd</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">new_subspace_index</span><span class="p">[</span><span class="n">dd</span><span class="p">]):</span>
                        <span class="c1"># if np.any(max_level_1d[:dd]==0):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">postponed_subspace_indices</span><span class="p">[</span>
                            <span class="n">hash_array</span><span class="p">(</span><span class="n">new_subspace_index</span><span class="p">)]</span> <span class="o">=</span> \
                                <span class="n">new_subspace_index</span>
                        <span class="n">use</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">use</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">new_subspace_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reactivated_subspace_indices_set</span><span class="p">:</span>
                    <span class="n">use_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postponed_subspace_indices</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">postponed_subspace_indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">new_active_subspace_indices</span> <span class="o">=</span> <span class="n">new_active_subspace_indices</span><span class="p">[:,</span> <span class="n">use_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reactivated_subspace_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_active_subspace_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span>
                <span class="n">new_active_subspace_indices</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">reactivated_subspace_indices</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">new_active_subspace_indices</span>

    <span class="k">def</span> <span class="nf">refine_subspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subspace_index</span><span class="p">):</span>
        <span class="n">new_active_subspace_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="p">):</span>
            <span class="n">neighbor_index</span> <span class="o">=</span> <span class="n">get_forward_neighbor</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">subspace_index_is_admissible</span><span class="p">(</span>
                <span class="n">neighbor_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices_dict</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">hash_array</span><span class="p">(</span><span class="n">neighbor_index</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">admissibility_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neighbor_index</span><span class="p">)):</span>
                <span class="n">new_active_subspace_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">new_active_subspace_indices</span><span class="p">,</span>
                     <span class="n">neighbor_index</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Subspace </span><span class="si">{</span><span class="n">neighbor_index</span><span class="si">}</span><span class="s1"> is not admissible&#39;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enforce_variable_ordering</span><span class="p">:</span>
            <span class="n">new_active_subspace_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postpone_subspace_refinement</span><span class="p">(</span>
                <span class="n">new_active_subspace_indices</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_active_subspace_indices</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span> <span class="ow">or</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refine</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">refine_and_add_new_subspaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">best_active_subspace_index</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">hash_array</span><span class="p">(</span><span class="n">best_active_subspace_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># get all new active subspace indices</span>
        <span class="n">new_active_subspace_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine_subspace</span><span class="p">(</span>
            <span class="n">best_active_subspace_index</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">new_active_subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_new_subspace_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_new_subspaces</span><span class="p">(</span>
                <span class="n">new_active_subspace_indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_new_subspace_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">new_active_subspace_indices</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span>

    <span class="k">def</span> <span class="nf">get_subspace_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subspace_index</span><span class="p">,</span> <span class="n">unique_poly_indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Must be implemented by derived class</span>
<span class="sd">        This function should only be called when updating grid not interogating</span>
<span class="sd">        grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;get_subspace_samples must be implemented by derived class&quot;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">initialize_subspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subspace_index</span><span class="p">):</span>
        <span class="n">subspace_poly_indices</span> <span class="o">=</span> <span class="n">get_subspace_polynomial_indices</span><span class="p">(</span>
            <span class="n">subspace_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">univariate_growth_rule</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subspace_poly_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">,</span> <span class="n">unique_poly_indices</span><span class="p">,</span> \
            <span class="n">subspace_values_indices</span> <span class="o">=</span> <span class="n">add_unique_poly_indices</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">,</span> <span class="n">subspace_poly_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique_poly_indices_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_poly_indices_idx</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subspace_values_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_indices</span><span class="p">,</span> <span class="n">unique_poly_indices</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">unique_poly_indices</span>

    <span class="k">def</span> <span class="nf">initialize_subspaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_subspace_indices</span><span class="p">):</span>
        <span class="n">num_vars</span><span class="p">,</span> <span class="n">num_new_subspaces</span> <span class="o">=</span> <span class="n">new_subspace_indices</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">num_current_subspaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">num_current_subspaces</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_new_subspaces</span><span class="p">):</span>
            <span class="n">subspace_index</span> <span class="o">=</span> <span class="n">new_subspace_indices</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_subspace</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span><span class="p">[</span><span class="n">hash_array</span><span class="p">(</span><span class="n">subspace_index</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cnt</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">create_new_subspaces_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_subspace_indices</span><span class="p">):</span>
        <span class="n">num_current_subspaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_subspaces</span><span class="p">(</span><span class="n">new_subspace_indices</span><span class="p">)</span>
        <span class="n">num_vars</span><span class="p">,</span> <span class="n">num_new_subspaces</span> <span class="o">=</span> <span class="n">new_subspace_indices</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">new_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_vars</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># num_current_subspaces = self.subspace_indices.shape[1]</span>
        <span class="c1"># cnt = num_current_subspaces</span>
        <span class="n">num_new_subspace_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_new_subspaces</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_new_subspaces</span><span class="p">):</span>
            <span class="n">subspace_index</span> <span class="o">=</span> <span class="n">new_subspace_indices</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
            <span class="c1"># unique_poly_indices = self.initialize_subspace(subspace_index)</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_poly_indices_idx</span><span class="p">[</span><span class="n">num_current_subspaces</span><span class="o">+</span><span class="n">ii</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">num_new_subspaces</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_poly_indices_idx</span><span class="p">[</span><span class="n">num_current_subspaces</span><span class="o">+</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">unique_poly_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices</span><span class="p">[:,</span> <span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span>
            <span class="n">unique_subspace_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subspace_samples</span><span class="p">(</span>
                <span class="n">subspace_index</span><span class="p">,</span> <span class="n">unique_poly_indices</span><span class="p">)</span>
            <span class="n">new_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">new_samples</span><span class="p">,</span> <span class="n">unique_subspace_samples</span><span class="p">))</span>
            <span class="n">num_new_subspace_samples</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_subspace_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># self.active_subspace_indices_dict[hash_array(subspace_index)]=cnt</span>
            <span class="c1"># cnt += 1</span>
        <span class="k">return</span> <span class="n">new_samples</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span>

    <span class="k">def</span> <span class="nf">add_new_subspaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_subspace_indices</span><span class="p">):</span>
        <span class="n">new_samples</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_new_subspaces_data</span><span class="p">(</span>
            <span class="n">new_subspace_indices</span><span class="p">)</span>

        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">(</span><span class="n">new_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span> <span class="n">new_subspace_indices</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_samples</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;New values cannot have NaN!&quot;</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">new_values</span><span class="p">))</span> <span class="o">==</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">new_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">new_values</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_equivalent_function_evaluations</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cost</span><span class="p">(</span>
            <span class="n">new_subspace_indices</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">num_new_subspace_samples</span>

    <span class="k">def</span> <span class="nf">prioritize_active_subspaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_active_subspace_indices</span><span class="p">,</span>
                                    <span class="n">num_new_subspace_samples</span><span class="p">):</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>\
            <span class="n">new_active_subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_active_subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">subspace_index</span> <span class="o">=</span> <span class="n">new_active_subspace_indices</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>

            <span class="n">priority</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_indicator</span><span class="p">(</span>
                <span class="n">subspace_index</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">priority</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="p">[</span><span class="n">error</span><span class="p">]])</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;adding new index </span><span class="si">{</span><span class="n">subspace_index</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;with priority </span><span class="si">{</span><span class="n">priority</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">set_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">variable_transformation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span> <span class="o">=</span> <span class="n">variable_transformation</span>

    <span class="k">def</span> <span class="nf">map_config_samples_from_canonical_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">config_variables_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">config_variables_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span>
        <span class="n">config_samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">config_variables_idx</span><span class="p">:,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_var_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">config_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_var_trans</span><span class="o">.</span><span class="n">map_from_canonical</span><span class="p">(</span>
                <span class="n">config_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">config_samples</span>

    <span class="k">def</span> <span class="nf">map_random_samples_from_canonical_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">canonical_samples</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">config_variables_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">config_variables_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span>
        <span class="n">random_samples</span> <span class="o">=</span> <span class="n">canonical_samples</span><span class="p">[:</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">random_samples</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">map_from_canonical</span><span class="p">(</span>
                    <span class="n">random_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">random_samples</span>

    <span class="k">def</span> <span class="nf">eval_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">canonical_samples</span><span class="p">):</span>
        <span class="n">random_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_random_samples_from_canonical_space</span><span class="p">(</span>
            <span class="n">canonical_samples</span><span class="p">)</span>
        <span class="n">config_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_config_samples_from_canonical_space</span><span class="p">(</span>
            <span class="n">canonical_samples</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">random_samples</span><span class="p">,</span> <span class="n">config_samples</span><span class="p">))</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">set_univariate_growth_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">univariate_growth_rule</span><span class="p">,</span>
                                    <span class="n">unique_quadrule_indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        self.config_variable_idx must be set if univariate_growth_rule is</span>
<span class="sd">        a callable function and not a lisf of callable functions. Otherwise</span>
<span class="sd">        errors such as assert len(growth_rule_1d)==config_variables_idx will</span>
<span class="sd">        be thrown</span>

<span class="sd">        TODO: eventually retire self.univariate_growth rule and just pass</span>
<span class="sd">        around compact_growth_rule. When doing this change from storing</span>
<span class="sd">        samples_1d for each dimension to only storing for unique quadrature</span>
<span class="sd">        rules</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span> <span class="o">=</span> <span class="n">unique_quadrule_indices</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">univariate_growth_rule</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span> <span class="o">=</span> <span class="p">[</span><span class="n">univariate_growth_rule</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dd</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span> <span class="o">=</span> <span class="n">univariate_growth_rule</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cnt</span> <span class="o">!=</span> <span class="n">dd</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;unique_quad_rule_indices is inconsistent with num_vars&#39;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">univariate_growth_rule</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dd</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">)):</span>
                <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">jj</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">univariate_growth_rule</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span>\
                        <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dd</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;length of growth_rules is inconsitent with num_vars.&#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Maybe you need to set unique_quadrule_indices&#39;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">univariate_growth_rule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">univariate_growth_rule</span><span class="p">)</span> <span class="o">==</span> <span class="n">dd</span>

    <span class="k">def</span> <span class="nf">set_refinement_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refinement_indicator</span><span class="p">,</span>
                                 <span class="n">admissibility_function</span><span class="p">,</span>
                                 <span class="n">univariate_growth_rule</span><span class="p">,</span>
                                 <span class="n">cost_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">work_qoi_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">unique_quadrule_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        cost_function : callable (or object is work_qoi_index is not None)</span>
<span class="sd">            Return the cost of evaluating a function with a unique indentifier.</span>
<span class="sd">            Identifiers can be strings, integers, etc. The identifier</span>
<span class="sd">            is found by mapping the sparse grid canonical_config_samples which</span>
<span class="sd">            are consecutive integers 0,1,... using self.config_var_trans</span>

<span class="sd">        work_qoi_index : integer (default None)</span>
<span class="sd">            If provided self.function is assumed to return the work (typically</span>
<span class="sd">            measured in wall time) taken to evaluate each sample. The work</span>
<span class="sd">            for each sample return as a QoI in the column indexed by</span>
<span class="sd">            work_qoi_index. The work QoI is ignored by the sparse grid</span>
<span class="sd">            eval_function() member function. If work_qoi_index is provided</span>
<span class="sd">            cost_function() must be a class with a member function</span>
<span class="sd">            update(config_samples,costs). config_samples is a 2d array whose</span>
<span class="sd">            columns are unique identifiers of the model being evaluated and</span>
<span class="sd">            costs is the work needed to evaluate that model. If building single</span>
<span class="sd">            fidelity sparse grid then config vars is set to be (0,...,0) for</span>
<span class="sd">            each sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refinement_indicator</span> <span class="o">=</span> <span class="n">refinement_indicator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">admissibility_function</span> <span class="o">=</span> <span class="n">admissibility_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_univariate_growth_rules</span><span class="p">(</span>
            <span class="n">univariate_growth_rule</span><span class="p">,</span> <span class="n">unique_quadrule_indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cost_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cost_function</span> <span class="o">=</span> <span class="n">default_combination_sparse_grid_cost_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_function</span> <span class="o">=</span> <span class="n">cost_function</span>
        <span class="k">if</span> <span class="n">work_qoi_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;This option is deprecated and will be removed&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_config_variable_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">config_var_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Must call set_function before entry&#39;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_var_trans</span> <span class="o">=</span> <span class="n">config_var_trans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_config_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">num_vars</span><span class="p">()</span> <span class="o">==</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_var_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_config_vars</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_var_trans</span><span class="o">.</span><span class="n">num_vars</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">eval_cost_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
        <span class="n">config_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_config_samples_from_canonical_space</span><span class="p">(</span>
            <span class="n">samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># single fidelity so make up dummy unique key for work tracker</span>
            <span class="n">config_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">costs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_function</span><span class="p">(</span><span class="n">config_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">costs</span>

    <span class="k">def</span> <span class="nf">get_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subspace_indices</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">num_new_subspace_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># the cost of a single evaluate of each function</span>
        <span class="n">function_costs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_cost_function</span><span class="p">(</span><span class="n">subspace_indices</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">function_costs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c1"># the cost of evaluating the unique points of each subspace</span>
        <span class="n">subspace_costs</span> <span class="o">=</span> <span class="n">function_costs</span><span class="o">*</span><span class="n">num_new_subspace_samples</span>
        <span class="c1"># the cost of evaluating the unique points of all subspaces in</span>
        <span class="c1"># subspace_indices</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">subspace_costs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cost</span>

    <span class="k">def</span> <span class="nf">__neq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function will compare all attributes of the derived class and this</span>
<span class="sd">        base class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">member_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">member_names</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="c1"># print(m)</span>
            <span class="c1"># print(type(attr))</span>
            <span class="c1"># print(attr)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="n">partial</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">partial_functions_equal</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lists_of_arrays_equal</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span>
                    <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lists_of_lists_of_arrays_equal</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">recompute_active_subspace_priorities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">extract_items_from_priority_queue</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span> <span class="o">=</span> <span class="n">mypriorityqueue</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># index of grid.subspace_indices</span>
            <span class="c1"># find num_samples for subspace</span>
            <span class="n">subspace_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">[:,</span> <span class="n">count</span><span class="p">]</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_poly_indices_idx</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_poly_indices_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_poly_indices_idx</span><span class="p">[</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">num_new_subspace_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices</span><span class="p">[:,</span> <span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># compute priority and error for subspace</span>
            <span class="n">priority</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_indicator</span><span class="p">(</span>
                <span class="n">subspace_index</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">new_item</span> <span class="o">=</span> <span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">new_item</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>

    <span class="k">def</span> <span class="nf">get_total_work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_equivalent_function_evaluations</span>


<span class="k">def</span> <span class="nf">get_unique_quadrule_variables</span><span class="p">(</span><span class="n">var_trans</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will create a quad rule for each variable type with different</span>
<span class="sd">    scaling. This can cause redundant computation of quad rules which</span>
<span class="sd">    may be significant when using leja sequences</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_quadrule_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_trans</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">unique_variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">unique_quadrule_indices</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">var_trans</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">unique_variable_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">var_trans</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">nunique_vars</span><span class="p">):</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">var_trans</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">unique_variables</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">var_indices</span> <span class="o">=</span> <span class="n">var_trans</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">unique_variable_indices</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_quadrule_variables</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">variable_shapes_equivalent</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">unique_quadrule_variables</span><span class="p">[</span><span class="n">jj</span><span class="p">]):</span>
                <span class="n">unique_quadrule_indices</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">unique_quadrule_indices</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">var_indices</span><span class="p">])</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">unique_quadrule_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="n">unique_quadrule_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_indices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unique_quadrule_variables</span><span class="p">,</span> <span class="n">unique_quadrule_indices</span>


<span class="k">def</span> <span class="nf">get_unique_max_level_1d</span><span class="p">(</span><span class="n">var_trans</span><span class="p">,</span> <span class="n">growth_rules</span><span class="p">):</span>
    <span class="n">unique_quadrule_variables</span><span class="p">,</span> <span class="n">unique_quadrule_indices</span> <span class="o">=</span> \
        <span class="n">get_unique_quadrule_variables</span><span class="p">(</span><span class="n">var_trans</span><span class="p">)</span>
    <span class="c1"># print(len(growth_rules), unique_quadrule_indices)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">growth_rules</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_quadrule_indices</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;growth rules and unique_quadrule_indices&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39; (derived from var_trans) are inconsistent&#39;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">max_level_1d</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_quadrule_indices</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">is_bounded_discrete_variable</span><span class="p">(</span><span class="n">unique_quadrule_variables</span><span class="p">[</span><span class="n">ii</span><span class="p">]):</span>
            <span class="n">max_nsamples_ii</span> <span class="o">=</span> <span class="n">get_probability_masses</span><span class="p">(</span>
                <span class="n">unique_quadrule_variables</span><span class="p">[</span><span class="n">ii</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">growth_rules</span><span class="p">[</span><span class="n">ii</span><span class="p">](</span><span class="n">ll</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_nsamples_ii</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">max_level_1d_ii</span> <span class="o">=</span> <span class="n">ll</span><span class="o">-</span><span class="mi">1</span>
                    <span class="k">break</span>
                <span class="n">ll</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_level_1d_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="n">max_level_1d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_level_1d_ii</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">max_level_1d</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_sparse_grid_univariate_leja_quadrature_rules_economical</span><span class="p">(</span>
        <span class="n">var_trans</span><span class="p">,</span> <span class="n">growth_rules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="n">growth_incr</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of unique quadrature rules. If each dimension has the same</span>
<span class="sd">    rule then list will only have one entry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">var_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">growth_rules</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">growth_incr</span> <span class="o">==</span> <span class="s1">&#39;clenshaw&#39;</span><span class="p">:</span>
            <span class="n">growth_rules</span> <span class="o">=</span> <span class="n">clenshaw_curtis_rule_growth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">growth_rules</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">constant_increment_growth_rule</span><span class="p">,</span> <span class="n">growth_incr</span><span class="p">)</span>

    <span class="n">unique_quadrule_variables</span><span class="p">,</span> <span class="n">unique_quadrule_indices</span> <span class="o">=</span> \
        <span class="n">get_unique_quadrule_variables</span><span class="p">(</span><span class="n">var_trans</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">growth_rules</span><span class="p">):</span>
        <span class="n">growth_rules</span> <span class="o">=</span> <span class="p">[</span><span class="n">growth_rules</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_quadrule_indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">growth_rules</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_quadrule_indices</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;growth rules and unique_quadrule_indices&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39; (derived from var_trans) are inconsistent&#39;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">quad_rules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_quadrule_indices</span><span class="p">)):</span>
        <span class="n">quad_rule</span> <span class="o">=</span> <span class="n">get_univariate_leja_quadrature_rule</span><span class="p">(</span>
            <span class="n">unique_quadrule_variables</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">growth_rules</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">quad_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quad_rule</span><span class="p">)</span>

    <span class="n">max_level_1d</span> <span class="o">=</span> <span class="n">get_unique_max_level_1d</span><span class="p">(</span><span class="n">var_trans</span><span class="p">,</span> <span class="n">growth_rules</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">quad_rules</span><span class="p">,</span> <span class="n">growth_rules</span><span class="p">,</span> <span class="n">unique_quadrule_indices</span><span class="p">,</span> <span class="n">max_level_1d</span>


<span class="k">def</span> <span class="nf">get_sparse_grid_univariate_leja_quadrature_rules</span><span class="p">(</span>
        <span class="n">var_trans</span><span class="p">,</span> <span class="n">growth_rules</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of quadrature rules for every variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">unique_quad_rules</span><span class="p">,</span> <span class="n">unique_growth_rules</span><span class="p">,</span> <span class="n">unique_quadrule_indices</span><span class="p">,</span>
     <span class="n">unique_max_level_1d</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
         <span class="n">get_sparse_grid_univariate_leja_quadrature_rules_economical</span><span class="p">(</span>
             <span class="n">var_trans</span><span class="p">,</span> <span class="n">growth_rules</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
    <span class="n">quad_rules</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">var_trans</span><span class="o">.</span><span class="n">num_vars</span><span class="p">()]</span>
    <span class="n">growth_rules</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">var_trans</span><span class="o">.</span><span class="n">num_vars</span><span class="p">()]</span>
    <span class="n">max_level_1d</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">var_trans</span><span class="o">.</span><span class="n">num_vars</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">quad_rule</span><span class="p">,</span> <span class="n">growth_rule</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">max_level</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">unique_quad_rules</span><span class="p">,</span> <span class="n">unique_growth_rules</span><span class="p">,</span> <span class="n">unique_quadrule_indices</span><span class="p">,</span>
            <span class="n">unique_max_level_1d</span><span class="p">):</span>
        <span class="n">quad_rules</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad_rule</span>
        <span class="n">growth_rules</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">growth_rule</span>
        <span class="n">max_level_1d</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_level</span>
    <span class="k">return</span> <span class="n">quad_rules</span><span class="p">,</span> <span class="n">growth_rules</span><span class="p">,</span> <span class="n">max_level_1d</span>


<div class="viewcode-block" id="CombinationSparseGrid"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid">[docs]</a><span class="k">class</span> <span class="nc">CombinationSparseGrid</span><span class="p">(</span><span class="n">SubSpaceRefinementManager</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adaptive sparse grid that uses the combination technique.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">,</span> <span class="n">basis_type</span><span class="o">=</span><span class="s2">&quot;barycentric&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        num_vars : integer</span>
<span class="sd">            The number of variables</span>

<span class="sd">        basis_type : string (default=&quot;barycentric&quot;)</span>
<span class="sd">           Specify the basis type to use. Currently the same basis must be used</span>
<span class="sd">           for all dimensions. Options &quot;barycentric&quot;, &quot;linear&quot;, &quot;quadratic&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CombinationSparseGrid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_vars</span><span class="p">)</span>

        <span class="c1"># to allow for mixed barycentric and piecwise poly basis</span>
        <span class="c1"># if type(basis_type) == str:</span>
        <span class="c1">#    basis_type = [basis_type]*num_vars</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">basis_type</span> <span class="o">=</span> <span class="n">basis_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">univariate_quad_rule</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_1d</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_quad_rule</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># extra storage to reduce cost of repeated interrogation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_moments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_interrogation_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">canonical_interrogation_samples</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="CombinationSparseGrid.setup"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">config_variables_idx</span><span class="p">,</span> <span class="n">refinement_indicator</span><span class="p">,</span>
              <span class="n">admissibility_function</span><span class="p">,</span> <span class="n">univariate_growth_rule</span><span class="p">,</span>
              <span class="n">univariate_quad_rule</span><span class="p">,</span>
              <span class="n">variable_transformation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">config_var_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">cost_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">work_qoi_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">unique_quadrule_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_function</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">variable_transformation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">config_variables_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config_variable_index</span><span class="p">(</span>
                <span class="n">config_variables_idx</span><span class="p">,</span> <span class="n">config_var_trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_refinement_functions</span><span class="p">(</span>
            <span class="n">refinement_indicator</span><span class="p">,</span> <span class="n">admissibility_function</span><span class="p">,</span>
            <span class="n">univariate_growth_rule</span><span class="p">,</span> <span class="n">cost_function</span><span class="p">,</span> <span class="n">work_qoi_index</span><span class="p">,</span>
            <span class="n">unique_quadrule_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_univariate_rules</span><span class="p">(</span><span class="n">univariate_quad_rule</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.set_univariate_rules"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.set_univariate_rules">[docs]</a>    <span class="k">def</span> <span class="nf">set_univariate_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">univariate_quad_rule</span><span class="p">,</span> <span class="n">max_level</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">univariate_growth_rule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Must call set_refinement_functions before set_univariate &quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;rules&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">univariate_quad_rule</span> <span class="o">=</span> <span class="n">univariate_quad_rule</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span>

        <span class="n">num_random_vars</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">)):</span>
            <span class="n">num_random_vars</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">num_random_vars</span> <span class="o">!=</span> <span class="n">dd</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;unique_quadrule_indices is inconsistent with &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;self.config_variables_idx. If using config_variables try&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;calling the following functions in this order&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                   set_function()</span>
<span class="s2">                   set_config_variable_index()</span>
<span class="s2">                   set_refinement_functions()</span>
<span class="s2">                   set_univariate_rules()</span>
<span class="s2">                   &quot;&quot;&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">univariate_quad_rule</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_quad_rule</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">univariate_quad_rule</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_quad_rule</span> <span class="o">=</span> <span class="n">univariate_quad_rule</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">univariate_quad_rule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_quad_rule</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_quad_rule</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">univariate_quad_rule</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dd</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">)):</span>
                <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">jj</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">univariate_quad_rule</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_quad_rule</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">univariate_quad_rule</span><span class="p">)</span> <span class="o">==</span> <span class="n">dd</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_1d</span> <span class="o">=</span> <span class="n">get_1d_samples_weights</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_quad_rule</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span><span class="p">,</span>
            <span class="p">[</span><span class="n">max_level</span><span class="p">]</span><span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.refine_and_add_new_subspaces"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.refine_and_add_new_subspaces">[docs]</a>    <span class="k">def</span> <span class="nf">refine_and_add_new_subspaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">best_active_subspace_index</span><span class="p">):</span>
        <span class="n">new_active_subspace_indices</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span>
            <span class="n">CombinationSparseGrid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">refine_and_add_new_subspaces</span><span class="p">(</span>
            <span class="n">best_active_subspace_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span> <span class="o">=</span> <span class="n">update_smolyak_coefficients</span><span class="p">(</span>
            <span class="n">best_active_subspace_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_active_subspace_indices</span><span class="p">,</span> <span class="n">num_new_subspace_samples</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.get_subspace_samples"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.get_subspace_samples">[docs]</a>    <span class="k">def</span> <span class="nf">get_subspace_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subspace_index</span><span class="p">,</span> <span class="n">unique_poly_indices</span><span class="p">):</span>
        <span class="n">samples_1d</span><span class="p">,</span> <span class="n">weights_1d</span> <span class="o">=</span> <span class="n">update_1d_samples_weights</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_quad_rule</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span><span class="p">,</span>
            <span class="n">subspace_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_1d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">get_sparse_grid_samples</span><span class="p">(</span>
            <span class="n">unique_poly_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.__call__"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">return_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        config values are ignored. The sparse grid just returns its best</span>
<span class="sd">        approximation of the highest fidelity model. TODO: consider enforcing</span>
<span class="sd">        that samples do not have configure variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">canonical_samples</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">map_to_canonical</span><span class="p">(</span>
                    <span class="n">samples</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">canonical_samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">evaluate_sparse_grid</span><span class="p">(</span>
            <span class="n">canonical_samples</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="p">:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="n">return_grad</span><span class="o">=</span><span class="n">return_grad</span><span class="p">,</span>
            <span class="n">basis_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_grad</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">vals</span><span class="p">,</span> <span class="n">jacs</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">if</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">jacs</span> <span class="o">=</span> <span class="n">jacs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">vals</span><span class="p">,</span> <span class="n">jacs</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.moments_"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.moments_">[docs]</a>    <span class="k">def</span> <span class="nf">moments_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smolyak_coefficients</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">integrate_sparse_grid_from_subspace_moments</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span> <span class="n">smolyak_coefficients</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_moments</span><span class="p">)</span></div>

        <span class="c1"># return integrate_sparse_grid(</span>
        <span class="c1">#     self.values,</span>
        <span class="c1">#     self.poly_indices_dict,self.subspace_indices,</span>
        <span class="c1">#     self.subspace_poly_indices_list,</span>
        <span class="c1">#     smolyak_coefficients,self.weights_1d,</span>
        <span class="c1">#     self.subspace_values_indices_list,</span>
        <span class="c1">#     self.config_variables_idx)</span>

<div class="viewcode-block" id="CombinationSparseGrid.moments"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.moments">[docs]</a>    <span class="k">def</span> <span class="nf">moments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">)</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.set_interrogation_samples"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.set_interrogation_samples">[docs]</a>    <span class="k">def</span> <span class="nf">set_interrogation_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set samples which are used to evaluate a sparse grid repeatedly.</span>
<span class="sd">        If provided each time a subspace is added the subspace is evaluated</span>
<span class="sd">        at these points so that when self.evaluate_at_interrogation_samples</span>
<span class="sd">        is called no major computations are required.</span>
<span class="sd">        Note the reduced time complexity requires more storage</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples : np.ndarray (num_vars) or (num_vars-num_config_vars)</span>
<span class="sd">             Samples at which to evaluate the sparae grid. If config values</span>
<span class="sd">             are provided they are ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">canonical_samples</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">map_to_canonical</span><span class="p">(</span>
                    <span class="n">samples</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">canonical_samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">canonical_interrogation_samples</span> <span class="o">=</span> <span class="n">canonical_samples</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.evaluate_at_interrogation_samples"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.evaluate_at_interrogation_samples">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_at_interrogation_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the sparse grid at self.canonical_interrogation_samples.</span>

<span class="sd">        Note, this fuction only uses subspaces which are not active</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">evaluate_sparse_grid_from_subspace_values</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_interrogation_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.evaluate_using_all_data"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.evaluate_using_all_data">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_using_all_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate sparse grid using all subspace indices including</span>
<span class="sd">        active subspaces. __call__ only uses subspaces which are not active</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># extract active subspaces from queue without destroying queue</span>
        <span class="n">pairs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span> <span class="o">=</span> \
            <span class="n">extract_items_from_priority_queue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_subspace_queue</span><span class="p">)</span>
        <span class="c1"># copy smolyak coefficients so as not affect future refinement</span>
        <span class="n">smolyak_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smolyak_coefficients</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># add all active subspaces to sparse grid by updating smolyak</span>
        <span class="c1"># coefficients</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)):</span>
            <span class="n">subspace_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">[:,</span> <span class="n">pairs</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">smolyak_coefficients</span> <span class="o">=</span> <span class="n">update_smolyak_coefficients</span><span class="p">(</span>
                <span class="n">subspace_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
                <span class="n">smolyak_coefficients</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">canonical_samples</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">map_to_canonical</span><span class="p">(</span>
                    <span class="n">samples</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">canonical_samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># evaluate sparse grid includding active subspaces</span>
        <span class="n">approx_values</span> <span class="o">=</span> <span class="n">evaluate_sparse_grid</span><span class="p">(</span>
            <span class="n">canonical_samples</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_indices_dict</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_poly_indices_list</span><span class="p">,</span>
            <span class="n">smolyak_coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">approx_values</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.add_new_subspaces"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.add_new_subspaces">[docs]</a>    <span class="k">def</span> <span class="nf">add_new_subspaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_subspace_indices</span><span class="p">):</span>
        <span class="n">num_new_subspaces</span> <span class="o">=</span> <span class="n">new_subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">num_current_subspaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">num_new_subspace_samples</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span>
            <span class="n">CombinationSparseGrid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_new_subspaces</span><span class="p">(</span>
                <span class="n">new_subspace_indices</span><span class="p">)</span>

        <span class="n">cnt</span> <span class="o">=</span> <span class="n">num_current_subspaces</span>
        <span class="n">new_subspace_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="n">num_new_subspaces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_new_subspaces</span><span class="p">):</span>
            <span class="n">subspace_index</span> <span class="o">=</span> <span class="n">new_subspace_indices</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
            <span class="n">subspace_values</span> <span class="o">=</span> <span class="n">get_subspace_values</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_values_indices_list</span><span class="p">[</span><span class="n">cnt</span><span class="p">])</span>
            <span class="n">subspace_moments</span> <span class="o">=</span> <span class="n">integrate_sparse_grid_subspace</span><span class="p">(</span>
                <span class="n">subspace_index</span><span class="p">,</span> <span class="n">subspace_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_1d</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">)</span>
            <span class="n">new_subspace_moments</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">subspace_moments</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_interrogation_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if storage becomes a problem may need to remove subspace</span>
                <span class="c1"># values when they have a non-zero smolyak coefficient and</span>
                <span class="c1"># recompute it if needed again</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subspace_interrogation_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">evaluate_sparse_grid_subspace</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">canonical_interrogation_samples</span><span class="p">,</span> <span class="n">subspace_index</span><span class="p">,</span>
                        <span class="n">subspace_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">config_variables_idx</span><span class="p">))</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_moments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_moments</span> <span class="o">=</span> <span class="n">new_subspace_moments</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspace_moments</span><span class="p">,</span> <span class="n">new_subspace_moments</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">num_new_subspace_samples</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.save"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_object</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Initial attempt to save failed. Likely self.function &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;cannot be pickled. Trying to save setting function to None&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_object</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Second save was successful&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="CombinationSparseGrid.get_samples"><a class="viewcode-back" href="../../../../api/pyapprox.surrogates.CombinationSparseGrid.html#pyapprox.surrogates.CombinationSparseGrid.get_samples">[docs]</a>    <span class="k">def</span> <span class="nf">get_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">map_from_canonical</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">(nvars=</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">plot_adaptive_sparse_grid_3d</span><span class="p">(</span><span class="n">sparse_grid</span><span class="p">,</span> <span class="n">plot_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figaspect</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
    <span class="n">active_subspace_indices</span><span class="p">,</span> <span class="n">active_subspace_idx</span> <span class="o">=</span> <span class="n">get_active_subspace_indices</span><span class="p">(</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">active_subspace_indices_dict</span><span class="p">,</span>
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">)</span>

    <span class="c1"># get subspace indices that have been added to the sparse grid,</span>
    <span class="c1"># i.e are not active</span>
    <span class="n">sparse_grid_subspace_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
        <span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">sparse_grid_subspace_idx</span><span class="p">[</span><span class="n">active_subspace_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">nn</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">plot_grid</span><span class="p">:</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">active_subspace_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">active_subspace_indices</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">plot_3d_indices</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">active_subspace_indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_grid</span><span class="p">:</span>
        <span class="n">samples</span><span class="p">,</span> <span class="n">active_samples</span> <span class="o">=</span> <span class="n">partition_sparse_grid_samples</span><span class="p">(</span><span class="n">sparse_grid</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">samples</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">active_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">active_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">active_samples</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>

        <span class="n">angle</span> <span class="o">=</span> <span class="mi">45</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
        <span class="c1"># ax.set_axis_off()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Hide axes ticks</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zticks</span><span class="p">([])</span>


<span class="k">def</span> <span class="nf">insitu_update_sparse_grid_quadrature_rule</span><span class="p">(</span><span class="n">sparse_grid</span><span class="p">,</span>
                                              <span class="n">quadrule_variables</span><span class="p">,</span>
                                              <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
    <span class="n">num_vars</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">num_vars</span>
    <span class="n">num_random_vars</span> <span class="o">=</span> <span class="n">num_vars</span><span class="o">-</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">num_config_vars</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">quadrule_variables</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_random_vars</span>
    <span class="c1"># univariate_growth_rules = []</span>
    <span class="n">unique_quadrule_indices</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_random_vars</span><span class="p">)]</span>
    <span class="n">new_var_trans</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span>
        <span class="n">quadrule_variables</span><span class="p">)</span>
    <span class="n">quad_rules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">max_levels</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># initial_points_list = []</span>
    <span class="n">growth_rules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_variable</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">marginals</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_random_vars</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">inds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">unique_quadrule_indices</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">growth_rule</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">compact_univariate_growth_rule</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
        <span class="n">growth_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">growth_rule</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">all_variable</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="n">quadrule_variables</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
            <span class="n">quad_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sparse_grid</span><span class="o">.</span><span class="n">compact_univariate_quad_rule</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
            <span class="k">continue</span>
        <span class="n">canonical_initial_points</span> <span class="o">=</span> \
            <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples_1d</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">max_levels</span><span class="p">[</span><span class="n">ii</span><span class="p">]][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># samples_1d are in the canonical domain map to old user domain</span>
        <span class="n">initial_points_old</span> <span class="o">=</span> \
            <span class="n">sparse_grid</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">map_from_canonical_1d</span><span class="p">(</span>
                <span class="n">canonical_initial_points</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
        <span class="c1"># map to new canonical domain</span>
        <span class="n">canonical_initial_points_new</span> <span class="o">=</span> <span class="n">new_var_trans</span><span class="o">.</span><span class="n">map_to_canonical_1d</span><span class="p">(</span>
                <span class="n">initial_points_old</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
        <span class="c1"># initial_points_list.append(canonical_initial_points_new)</span>

        <span class="n">quad_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_univariate_leja_quadrature_rule</span><span class="p">(</span>
            <span class="n">quadrule_variables</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">growth_rule</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
            <span class="n">initial_points</span><span class="o">=</span><span class="n">canonical_initial_points_new</span><span class="p">))</span>

    <span class="n">sparse_grid</span><span class="o">.</span><span class="n">set_univariate_growth_rules</span><span class="p">(</span>
        <span class="n">growth_rules</span><span class="p">,</span> <span class="n">unique_quadrule_indices</span><span class="p">)</span>
    <span class="n">max_level</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">subspace_indices</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">sparse_grid</span><span class="o">.</span><span class="n">set_univariate_rules</span><span class="p">(</span><span class="n">quad_rules</span><span class="p">,</span> <span class="n">max_level</span><span class="p">)</span>
    <span class="n">sparse_grid_samples</span> <span class="o">=</span> <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">sparse_grid_samples</span> <span class="o">=</span> \
        <span class="n">sparse_grid</span><span class="o">.</span><span class="n">var_trans</span><span class="o">.</span><span class="n">map_from_canonical</span><span class="p">(</span>
            <span class="n">sparse_grid_samples</span><span class="p">)</span>
    <span class="n">sparse_grid_samples</span> <span class="o">=</span> <span class="n">new_var_trans</span><span class="o">.</span><span class="n">map_to_canonical</span><span class="p">(</span>
        <span class="n">sparse_grid_samples</span><span class="p">)</span>
    <span class="n">sparse_grid</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">sparse_grid_samples</span>
    <span class="n">sparse_grid</span><span class="o">.</span><span class="n">var_trans</span> <span class="o">=</span> <span class="n">new_var_trans</span>
    <span class="k">return</span> <span class="n">sparse_grid</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Notes if use combination technique to manage only adaptive refinement in configure variables and another strategy (e.g. another independent combination technique to refine in stochastic space) then this will remove downward index constraint</span>
<span class="sd"># between subspaces that vary both models and parameters.</span>

<span class="sd">An Adaptive PCE can only use this aforementioned case. I do not see a way to</span>
<span class="sd">let each subspace still be a tensor product index and build an approximation only over tha subspace and then combine.</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019 National Technology &amp; Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>